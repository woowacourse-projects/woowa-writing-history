---
author: "mzeong"
generation: 6
level: "level4"
original_filename: "LEVEL4.md"
source: "https://github.com/woowacourse/woowa-writing/blob/mzeong/LEVEL4.md"
source_path: "LEVEL4.md"
---

# 인덱스 이해하고 적용하기

*이 글은 인덱스의 개념은 알고 있지만 실제 데이터베이스에서 인덱스를 설계하고 적용해 본 경험이 적은 서버 개발자를 위해 작성되었습니다.

## 목차

1. [인덱스란 무엇일까?](#인덱스란-무엇일까)
2. [인덱스는 어떻게 사용할까?](#인덱스는-어떻게-사용할까)
3. [인덱스를 어떻게 사용하는 게 좋을까?](#인덱스를-어떻게-사용하는-게-좋을까)

<br>

## 인덱스란 무엇일까?

### 인덱스 개념 및 필요성

인덱스는 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.

인덱스는 조건에 맞는 데이터를 빠르게 찾고, ORDER BY나 GROUP BY 연산을 효율적으로 수행하기 위해 필요하다. 인덱스가 없으면 풀 스캔(full scan)으로 전체 데이터를 탐색해야 하며, 이는 시간복잡도 O(N)이 소요된다. 반면, 인덱스를 사용하면 (B-Tree 기반 인덱스 기준) 시간복잡도 O(log N)만에 찾을 수 있다.

<br>

### 인덱스 자료구조

대부분의 데이터베이스에서 일반적으로 **B-Tree**를 사용한다. 
- B-Tree는 **이진 탐색 트리**(BST)를 일반화한 트리이다.
  - 이진 탐색 트리는 모든 노드의 왼쪽 서브 트리는 해당 노드의 값보다 작은 값들만, 오른쪽 서브 트리는 해당 노드의 값보다 큰 값들만 가진다. 자녀 노드는 최대 두 개까지 가능하다.
- B-Tree는 자녀 노드의 최대 개수를 늘리기 위해 부모 노드에 키(key)를 하나 이상 저장한다.

B-Tree는 모든 리프 노드가 동일한 레벨에 있어, 최악의 경우에도 시간복잡도가 O(log N)으로 일정하다. 반면, BST는 불균형할 경우 시간복잡도가 O(N)까지 증가할 수 있다.

> B-Tree를 인덱스에 쓰는 이유가 균형 트리이기 때문이라면 AVL tree, Red-Black tree와 같은 Self-Balancing BST를 사용해도 되지 않을까?
> 
> | **구분**                      | **Self-Balancing BST** | **B-Tree**                              |
> |-----------------------------|---------------------------------------------|------------------------------------------|
> | **조회, 삽입, 삭제 (avg case)**   | **O(log N)**                               | **O(log N)**                              |
> | **조회, 삽입, 삭제 (worst case)** | **O(log N)**               | **O(log N)**             |
> 
> <br>
> 
> 기본적으로 데이터베이스는 보조기억장치(Secondary Storage)에 저장되고, 블록(block) 단위로 데이터를 읽고 쓴다.
> - 보조기억장치는 데이터를 저장하는 용량은 가장 크지만, 처리하는 속도는 가장 느리다.
> - 블록의 크기는 2의 승수로 표현되므로 불필요한 데이터까지 읽어올 가능성이 있다.
> 
> 이러한 특성 때문에 데이터를 조회할 때는 보조기억장치에 최대한 적게 접근하고, 연관된 데이터를 모아서 저장하는 것이 성능 면에서 좋다.
> 
> B-Tree는 더 많은 자녀 노드를 가질 수 있으므로 Self-Balancing BST보다 유리하다.

> Hash는 데이터 조회, 삽입, 삭제하는 시간복잡도가 O(1)이다. 그렇다면 일반적으로 Hash 인덱스를 사용하는 게 좋지 않을까?
> 
> - Hash 인덱스는 등호(=) 연산만 지원하며, 범위 조건(<, >, BETWEEN)에는 사용할 수 없다.
> - Hash 인덱스는 컬럼 값을 해시로 변환해 저장하므로, 특정 문자로 시작하는 값 검색이나 정렬 같은 작업에는 사용할 수 없다.
> 
> 따라서, 등호 연산에 특화된 테이블이라면 Hash 인덱스를 사용하는 것이 적합하지만, 범위 검색이나 정렬이 필요한 경우 B-Tree가 더 적합하다.

<br>

### 인덱스 종류

#### Clustered vs. Non-Clustered

| 구분                | **Clustered**              | **Non-Clustered**                                                            |
|-------------------|----------------------------|-----------------------------------------------------------------------------------------------------------|
| **개수 제한**         | 테이블당 하나만 생성 가능             | 여러 개 생성 가능                                                                                         |
| **대상**            | 별도 지정이 없으면 기본 키(PK)가 설정    | 기본 키가 아닌 다른 컬럼에 대해 생성 가능                                                                      |
| **정렬 여부 및 저장 위치** | 인덱스에 데이터가 물리적으로 정렬된 상태로 저장 | 정렬되지 않으며, 별도의 인덱스 페이지에 논리적 위치 정보만 저장                                                |
| **데이터 접근 속도**     | 물리적 정렬 덕분에 검색 속도가 빠름       | 데이터 페이지와 별도로 저장되어 상대적으로 검색 속도가 느림                                                    |
| **DML 작업 성능**     | 정렬 상태를 유지해야 하므로 상대적으로 느림   | 작업 성능에 미치는 영향이 적음                                                                             |

<br>

## 인덱스는 어떻게 사용할까?

MySQL을 기준으로 사용법을 알아보자.

### 생성

`CREATE INDEX` 구문을 사용하거나, 테이블 생성 시 `CREATE TABLE` 구문에 인덱스를 포함시키는 방법이 있다.

**구문**

```sql
CREATE INDEX 인덱스_이름 ON 테이블_이름(열_이름1, 열_이름2);
```

```sql
CREATE TABLE 테이블_이름 ( 
	열_이름1 열_타입1, 
	열_이름2 열_타입2, 
	INDEX (열_이름1, 열_이름2) 
);
```

<br>

### 삭제

**구문**

```sql
DROP INDEX 인덱스_이름 ON 테이블_이름;
```

> 외래키가 포함된 인덱스를 삭제하려고 하면 에러가 발생한다.
> 
> <img width="1373" alt="image" src="https://github.com/user-attachments/assets/8a9e9727-acb6-4630-8753-042653f4532f">
> 
> 
> 이때는 외래키 제약조건을 먼저 삭제한 후 외래키 삭제를 진행하면 된다.
> 
> **구문**
> 
> ```sql
> ALTER TABLE 테이블_이름 DROP FOREIGN KEY 제약조건_이름;
> ```
> 
> ```sql
> ALTER TABLE 테이블_이름 ADD CONSTRAINT 제약조건_이름 
>     FOREIGN KEY (외래키_열_이름) REFERENCES 참조_테이블_이름 (참조_열_이름);
> ```
> **예시**
> 
> <img width="1302" alt="image" src="https://github.com/user-attachments/assets/21a27440-da33-48e9-87d3-fd8ae6ad5fbb">
> <img width="1279" alt="image" src="https://github.com/user-attachments/assets/5747ef2b-871a-43c9-9be1-4157380b0b2c">
> <img width="1278" alt="image" src="https://github.com/user-attachments/assets/0490b1ae-4e11-4d3c-8745-9191883f60ad">

<br>

### 수정

인덱스를 수정하는 구문은 없다. 인덱스를 수정하려면 기존 인덱스를 삭제한 후, 다시 생성해야 한다.

<br>

### 조회

**구문**

```sql
SHOW INDEX FROM 테이블_이름;
```

**예시**

구문을 통해 member 테이블에 복합 인덱스가 있음을 확인할 수 있다.

<img width="1004" alt="image" src="https://github.com/user-attachments/assets/f7528e5d-0c36-41d7-ae07-bb6b02829c3d">

<br>

### 성능 최적화

쿼리 성능을 향상하고 싶다면 **실행 계획**을 통해 진단해 볼 수 있다. 
- 실행 계획이란 데이터베이스가 데이터를 찾아가는 일련의 과정을 사람이 알아보기 쉽게 DB 결과 셋으로 보여주는 것이다.

쿼리 앞에 `EXPLAIN` 키워드를 사용하면 된다.

**구문**

```sql
EXPLAIN 쿼리;
```

MySQL 8.0.18 부터는 `EXPLAIN ANALYZE`로도 쿼리를 분석할 수 있다. 이는 실행 계획(estimated cost)뿐만 아니라 실제 실행했을 때 비용도 같이 보여준다.

```sql
EXPLAIN ANALYZE 쿼리;
```

> 보통 옵티마이저가 적절하게 인덱스를 선택한다. 하지만 직접 인덱스를 고르고 싶다면 아래 구문을 활용할 수 있다.
> 
> **구문**
> 
> `USE INDEX`는 쿼리에서 특정 인덱스만 사용하도록 힌트를 준다. 여러 인덱스가 있을 때, 특정 인덱스를 선택해서 성능을 개선할 수 있다.
> 
> ```sql
> SELECT .. FROM 테이블_이름 USE INDEX (인덱스_이름) WHERE ..;
> ```
> 
> `FORCE INDEX`는 `USE INDEX`보다 더 강력한 명령어로, 지정된 인덱스를 반드시 사용하게 만든다.
> 
> ```sql
> SELECT .. FROM 테이블_이름 FORCE INDEX (인덱스_이름) WHERE ..;
> ```
> 
> `IGNORE INDEX`는 특정 인덱스를 사용하지 말라고 지시하는 명령어이다. 해당 인덱스를 무시하고 다른 방식으로 데이터를 검색하도록 강제할 수 있다.
> 
> ```sql
> SELECT .. FROM 테이블_이름 IGNORE INDEX (인덱스_이름) WHERE ..;
> ```

<br>

## 인덱스를 어떻게 사용하는 게 좋을까?

### 데이터 양이 많을 때

데이터가 수백 건 이하이면 인덱스를 사용하지 않는 것이 더 효율적일 수 있다.

<br>

**데이터 100건**

- 인덱스 없을 때: 0.001 ms
<img width="1582" alt="image" src="https://github.com/user-attachments/assets/d7628214-b833-425a-a4bb-0d7814570b23">

- 인덱스 있을 때: 0.0022 ms
<img width="1582" alt="image" src="https://github.com/user-attachments/assets/d64ede80-2394-4e0f-b998-229b0ddca982">

**데이터 10만 건**

- 인덱스 없을 때: 71.361 ms
<img width="1582" alt="image" src="https://github.com/user-attachments/assets/002b1911-d2f9-4b75-ad8a-6a5b40873050">

- 인덱스 있을 때: 0.0017 ms
<img width="1582" alt="image" src="https://github.com/user-attachments/assets/b33f6706-adda-49b1-82ab-a339212b16d9">

### INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼일 때

DML 작업을 할 때 인덱스 관리에 따르는 추가 비용(인덱스 키 추가나 삭제 작업)이 발생한다.

인덱스 키 삭제 작업은 해당 키 값이 저장된 리프 노드를 찾아서 삭제 마크만 하면 돼서 간단하지만, 인덱스 키 추가나 변경 작업은 비용이 많이 든다. (*B-Tree 기준)
- 키 값이 저장될 리프 노드가 꽉 차면 리프 노드를 분리하기 위해 상위 브랜치 노드까지 처리 범위가 넓어진다.
- 키 값에 따라 저장될 리프 노드의 위치가 결정되므로 단순히 키 값만 변경하는 것은 불가능하다. 따라서, 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하게 된다.

> 레코드 추가 비용을 1로 가정하고 인덱스 추가 비용을 1.5로 예측하면, 인덱스 추가로 인해 INSERT, UPDATE 문장이 어떤 영향을 받을지 대략적으로 계산할 수 있다.
> 예. 테이블에 인덱스가 없으면 `1`, 3개면 `5.5(= 1 + 1.5 * 3)` 정도의 비용이 들 것

### WHERE, ORDER BY, GROUP BY 절에 자주 사용되는 컬럼일 때

기본적으로 자주 조회되는 컬럼에만 인덱스를 생성해야 한다.

### 카디널리티가 높은 컬럼일 때

카디널리티(cardinality)는 고유한 컬럼 값의 수를 의미한다. 중복도가 낮으면 카디널리티가 높다고 표현한다.

예를 들어, 성별 컬럼은 두 가지 경우의 데이터만 존재하므로 인덱스를 생성하면 비효율적이다. 값의 범위가 적은 컬럼은 디스크 I/O가 자주 발생하기 때문이다.

<br>

추가로, 인덱스 생성 시 참고할 점을 언급하자면 다음과 같다.

- 복합 인덱스는 인덱스 순서에 따라 효율성이 달라질 수 있다. 카디널리티가 높거나 쿼리에서 더 자주 사용되는 컬럼을 선두에 배치하는 것이 좋다.
- 복합 인덱스에 쿼리에 필요한 컬럼이 모두 포함되어 있다면 커버링 인덱스(covering index)를 활용할 수 있다. 인덱스만으로 필요한 데이터를 모두 조회할 수 있어 실제 테이블까지 갈 필요가 없으므로 조회 성능이 더 빠르다.

<br>

## 참고

https://dev.mysql.com/doc/refman/8.4/en/create-index.html

https://youtu.be/bqkcoSm_rCs?feature=shared

https://youtu.be/H_u28u0usjA?feature=shared

https://youtu.be/liPSnc6Wzfk?feature=shared

https://youtu.be/IMDH4iAQ6zM?feature=shared

https://nomadlee.com/mysql-explain-%ec%8b%a4%ed%96%89%ea%b3%84%ed%9a%8d-%ec%82%ac%ec%9a%a9%eb%b2%95-%eb%b0%8f-%eb%b6%84%ec%84%9d/

https://june-coder.tistory.com/64
