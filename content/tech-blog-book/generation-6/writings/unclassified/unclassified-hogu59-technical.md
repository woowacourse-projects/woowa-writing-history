---
author: "hogu59"
generation: 6
level: "unclassified"
original_filename: "Technical.md"
source: "https://github.com/woowacourse/woowa-writing/blob/hogu59/Technical.md"
source_path: "Technical.md"
---

# 안드로이드 개발자가 알아야 할 패턴에 관하여 (From MVC to MVVM)

---

## 문서 주제

- 안드로이드 개발에서 MVC 패턴부터 MVVM 패턴까지 어떤 점이 다르고 어떻게 적용할 수 있는지, 어떤 장/단점이 있는지 설명합니다.

## 대상 독자

- 안드로이드 프로젝트 생성 경험이 있는 사람
- 안드로이드 디자인 패턴을 적용해보고 싶은데 어떻게 적용할지 모르는 사람

---

## 목차

### **1. 패턴에 관하여**

- **1) 그게 뭐에요? (What)**
    - 디자인 패턴? vs 아키텍처 패턴?
- **2) 왜 써야해요? (Why)**
    - 패턴을 왜 사용해야 하는가?

### **2. 각 패턴에 관하여**

- **1) MVC 패턴**
    - 구조 및 동작 방식
    - 안드로이드에서의 MVC 프로젝트
    - 진짜 MVC 구조가 맞을까?
    - 비유
- **2) MVP 패턴**
    - 구조 및 작동 방식
    - MVC 와의 차이점
    - MVC 에서 MVP로 전환하는 방법
    - 장단점
- **3) MVVM 패턴**
    - 구조 및 작동 방식
    - MVVM 패턴을 쉽게 적용하는 방법
    - 장단점

### 3. **패턴 비교 및 선택 가이드**

- 어느 상황에서 패턴을 적용할 때, 적합한지 알아보자 (When)

---

# 1. 패턴에 관하여

## 1) 그게 뭐에요? (What)

프로그램을 개발한다면 유지보수성을 항상 염두에 두어야합니다. 이런 상황에서 사용되는 것이 바로 **패턴** 입니다. 패턴을 적용하면 코드 구조를 체계화할 수 있어 유지보수와 확장성이 높아집니다. 또한 각 구성 요소의 역할이 명확해지면서 개발 과정 자체도 체계화되어 생산성과 코드 품질을 향상시키는 데 기여합니다.

안드로이드 앱을 개발할 때에도 이러한 원칙은 동일하게 적용됩니다. 패턴을 사용하면 유지보수가 용이한 앱을 만들 수 있습니다. 안드로이드 프로젝트에 적용할 수 있는 패턴들을 빠르게 알아보고 싶겠지만, 첫번째 장에서는 패턴이 무엇인지, 그리고 왜 패턴이 필요한지 알아보려고 합니다. 무작정 도입해서 사용하는 것보다 그것이 왜 필요한지 깨닫고, 필요성을 알고 있을 때, 더욱 패턴에 대한 설명이 와닿을 것입니다.

### 디자인 패턴

디자인 패턴은 소프트웨어 디자인에서 공통적으로 발생하는 문제에 대해 재사용 가능한 해결책을 말합니다. 개발을 하며 마주하는 상황에 맞춰 사용될 수 있는 문제을 해결하는 방법(템플릿)을 의미합니다.

예를 들어 싱글턴 패턴은 클래스의 인스턴스를 하나만 생성하도록 하여 리소스 공유와 전역 접근을 용이하게 합니다. 옵저버 패턴은 주체-관찰자 관계를 정의하여 객체 간 느슨한 결합과 이벤트 기반 통신을 지원합니다.

이처럼 디자인 패턴은 검증된 솔루션을 제공하여 코드 품질과 개발 생산성을 높이는 데 효과적입니다. 실제 프로젝트에서 적절한 디자인 패턴을 선택하고 활용하는 것이 중요합니다.

### 아키텍처 패턴

아키텍처 패턴은 소프트웨어 시스템의 전반적인 구조와 구성 요소 간의 상호 작용을 정의하는 일반적인 지침입니다. 아키텍처 패턴은 시스템 수준에서 설계와 구현을 안내하여 확장성, 유연성, 성능 등을 높이는 데 도움이 됩니다.

아키텍처 패턴을 활용하면 복잡한 시스템을 체계적으로 설계하고 구현할 수 있으며, 유지보수와 확장이 용이해집니다. 따라서 아키텍처 패턴은 대규모 소프트웨어 시스템 개발에서 매우 중요합니다.

### 차이점

디자인 패턴과 아키텍처 패턴은 소프트웨어 설계에서 서로 다른 목적과 범위를 가지고 있습니다. 디자인 패턴은 객체 지향 설계 수준에서 특정 문제를 해결하기 위한 재사용 가능한 솔루션을 제공합니다. 반면 아키텍처 패턴은 전체 시스템 수준에서 구성 요소 간 상호 작용과 전반적인 구조를 정의합니다.

목적 및 적용 수준 측면에서 디자인 패턴은 클래스와 객체 수준의 설계 문제를 다루고, 아키텍처 패턴은 시스템 전체의 구조와 아키텍처를 결정합니다. 범위 측면에서 디자인 패턴은 특정 코드 수준의 문제에 초점을 맞추지만, 아키텍처 패턴은 전체 시스템의 큰 그림을 다룹니다.

따라서 이번에 다룰 안드로이드의 패턴은 아키텍처 패턴이라고 부르는 것이 적절할 것 같습니다.

## 2) **왜 써야해요? (Why)**

앞에서 어느정도 다뤘지만 쉬운 이해를 위해 상상을 해봅시다. 당신이 하나의 파일에서만 코드를 작성한다고 가정해봅시다. 당신은 수천줄의 코드를 작성했고, 수 백개의 각기 다른 로직들을 가지고 동작하는 멋진 서비스를 하나 만들었습니다. 당신의 상사는 당신에 “정말 유능하구만!” 이라고 말하며 당신을 칭찬했습니다. 그리고 세 달뒤, 당신의 기억에서 프로그램에 대한 내용이 잊혀질 것 같은 시점에 당신의 상사가 기대에 찬 얼굴로 당신을 찾아왔습니다. 상사는 “OO씨, 지난번에 만들어준 프로그램이 정말 좋은데, 이 기능 두 개만 추가해주면 좋겠어!” 라고 말하고 떠났습니다. 당신은 세 달 전 만든 프로젝트 파일을 열어보고 놀라며 다음과 같은 생각이 들었습니다. ‘맙소사. 어떤 흐름으로 코드가 진행되는거지? 흠.. 이 코드를 바꿔야할 것 같은데.. 어라? 바꾸면 또 다른 곳에서 문제가 생기네… 이걸 어떡한담…’

당신이 짠 코드더라도 시간이 지난후에 되돌아보면 남이 만든 코드처럼 생소하게 느껴집니다. 그럴때 코드가 마치 서랍장 안의 옷처럼 정돈되어 있었다면 어땠을까요? 어떤 기능을 하는 함수를 찾는것도 편리할 것이고, 함수를 고치거나 수정하는 것도 용이할 것입니다. 또 각자 분리되어있기 때문에, 수정한다고 해서 생기는 파급효과는 적거나 없을 것입니다.

마치 아래의 사진과 같습니다. 왼쪽 상황에서 제가 당신에게 '저기 안에 있는 콜라병을 꺼내고, 이 옷은 쓰레기통에 버려주세요. 그리고 저 비닐봉지는 에코백으로 바꿔주세요'라고 한다면, 수행하기 어려울 것입니다. 어떤게 어디있는지 알기도 어려울 뿐더러, 하나만 손을 대도 여러곳에서 문제가 생기기 때문이죠. 반대로 오른쪽 상황에서 제가 당신에게 “이 페트병 좀 버려주시고, 은색 깡통을 꺼내주세요”라고 한다면 당신은 번거로울 수는 있어도 불가능하다고 느끼지는 않을 것입니다.

이것이 패턴, 즉 구조를 나누는 이유입니다. 당신의 코드를 더 유연하게 만들고 유지보수가 용이하게 만드는 과정이죠!

<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/trashcan.jpg" width="200px"> <img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/recycle.png" width="300px">

# 2. 각 패턴에 관하여

## **1) MVC 패턴**

### 구조 및 동작 방식

<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/mvc1.png">

MVC(Model-View-Controller) 패턴은 애플리케이션의 데이터(Model), 사용자 인터페이스(View), 그리고 둘 사이의 제어 로직(Controller)을 명확히 분리하여 모듈성과 유지보수성을 높이는 아키텍처 패턴입니다.

MVC 패턴의 구조는 다음과 같습니다.

- Model: 애플리케이션의 핵심 데이터와 비즈니스 로직을 담당합니다. 데이터 처리와 관리를 책임집니다.
- View: 사용자 인터페이스를 구현하고 화면을 보여줍니다. 사용자의 입력을 받아 Controller에 전달합니다.
- Controller: Model과 View 사이의 중개자 역할을 합니다. 사용자의 입력을 Model에 전달하고, Model의 상태 변화를 View에 반영합니다.

### 안드로이드에서의 MVC 프로젝트

<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/android_mvc.png">

이제 새로운 가정을 해봅시다. 당신은 안드로이드 스튜디오로 새로운 프로젝트를 하나 생성했습니다. 그리고 아주 간단한 앱을 만들기 위해 모델 클래스를 하나 만들었습니다. 이제 당신의 앱은 위의 사진과 같은 구조가 되었을 것입니다. 지금의 구조로 본다면 적절하게 Model, Controller, 그리고 View로 나뉘어졌음을 알 수 있습니다. 축하합니다! 당신은 이제 MVC 패턴을 적용해서 프로젝트를 구성하게 되었습니다.

### 진짜 MVC 구조가 맞을까?

<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/android_mv.png">

위에서의 내용을 통해 당신은 이제 MVC 패턴을 적용했다고 느끼시겠지만, 유감스럽게도 당신의 프로젝트는 MVC 패턴이 아닙니다. 그 이유는 안드로이드 시스템의 구조적 한계에 있습니다. 안드로이드에서는 Activity 와 Fragment와 같은 코드는 컨트롤러가 아닌 View 로 분류되기 때문입니다. 그렇기에 사실상 당신이 만든 간단한 프로젝트는 MVC 패턴이 아닌 MV패턴(존재하는 패턴은 아닙니다)이라고 부르는 것이 적절할 것입니다.

### 비유

아직 MV패턴이라는 것을 받아들이지 못할 당신을 위해 비유를 하나 들어드리겠습니다. 당신은 왼쪽의 그림과 같이 모델, 뷰, 컨트롤러로 나누어진 삼인방을 만들었다고 생각하고 있을 것입니다. 하지만 사실은 오른쪽의 사진처럼 컨트롤러의 로직을 삼킨 뷰를 만든 것이죠. 뷰가 컨트롤러를 삼키고 있기 때문에 제대로 나누어지지 않았고, 로직이 나누어지지 않았다면, 위에서 말했던 것처럼 유지보수성이 떨어지게 될 것입니다. 이런 문제를 해결하기 위해 우리는 MVP 패턴을 살펴보고자 합니다.

<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/metaphor_mvc.png" width="400px">
<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/metaphor_mv.png" width="210px">

## **2) MVP 패턴**

### 구조 및 작동 방식

<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/mvp1.png">

지금 보시는 도식은 MVP 패턴의 구조입니다. 뷰가 사용자의 입력을 받으면 입력 이벤트를 프레젠터에게 전달하고, 프레젠터는 필요에 따라 자신이 가지고 있는 모델의 값을 변경합니다. 그리고 처음 들어왔던 이벤트를 처리하며 뷰에 변경사항이 필요하다면 프레젠터가 뷰에 변경요청(혹은 명령)을 하는 방식으로 작동하게 됩니다.

간단히 정리하면 아래와 같습니다.

- Model: 애플리케이션의 데이터와 비즈니스 로직을 담당합니다. MVC 패턴의 Model과 동일한 역할입니다.
- View: 화면을 구성하고, 사용자 입력을 받아 Presenter에게 전달하는 역할을 합니다. MVC 패턴의 View와 달리 Presenter를 참조합니다.
- Presenter: View와 Model 사이에 위치하며, View로부터 받은 사용자 입력을 처리하고 Model의 데이터를 조작한 후 변경된 데이터를 View에 전달합니다. 즉, View와 Model 간의 상호작용을 관리하는 역할을 합니다.

### MVC 와의 차이점

<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/mvp2.png">

상당히 MVC 패턴과 비슷하다는 것을 눈치 채셨을텐데, 사실상 안드로이드 시스템 상에서 가장 MVC 패턴에 적합한 구조라고 할 수 있습니다. 위에서 다뤘던 MVC 패턴은 사실상 MV 패턴에 가깝다보니, 뷰가 컨트롤러의 로직을 들고 있게 됩니다. 즉, 앱이 작동할 가장 큰 로직(혹은 흐름)을 뷰가 들고 있었죠. 이런 문제를 해결하기 위해 새롭게 로직을 위임할 하나의 존재를 만든 것이고, 그 이름이 프레젠터인 것이죠.

### MVC 에서 MVP로 전환하는 방법

이제 MVP 패턴이 어떤 것인지 알아보았으니, 실제로 어떻게 적용하는지도 알아보아야겠죠? 두 가지 단계를 거치면 간단하게 MVP 패턴으로 전환할 수 있습니다. 버튼을 누르면 토스트 메세지를 띄워주는 간단한 앱을 MVP 패턴으로 바꾸어 보겠습니다.

1. Contract 라는 이름의 인터페이스를 생성하고, 그 안에 View 와 Presenter 라는 이름의 인터페이스를 생성합니다. 여기서는 뷰가 프레젠터에게 이벤트를 전달하는 메서드와 프레젠터가 뷰에 (뷰) 변경을 요청하는 메서드의 명세를 작성하게 됩니다.

   <img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/mvp_code1.png">

2. Presenter 클래스를 만들고, Contract.Presenter 인터페이스를 상속받게 합니다. 그리고 기존에 존재하는 Activity 클래스는 Contract.View 인터페이스를 상속받게 합니다. Presenter와 Activity에서는 인터페이스에 있는 함수를 구체화함으로써 사용자 이벤트가 생길 때 어떻게 작동할 지 결정하게 됩니다.

   <img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/mvp_code2.png">

   <img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/mvp_code3.png">


### 장단점

이러한 방식으로 우리는 MVC 패턴의 코드를 MVVM 패턴의 코드로 변경해볼 수 있었습니다. 그렇다면 MVP 패턴을 사용할 때의 장단점을 알아보면 좋을 것 같습니다.

1. 장점
    - 역할에 따라 분리가 이루어짐 (컨트롤러의 로직이 따로 분리됨)
    - 모델과 뷰 사이의 의존성이 줄어들거나 없어집니다.
2. 단점
    - 뷰와 프레젠터가 강력하게 결합하게 됩니다. 즉, 서로 강하게 의존하게 됩니다.
    - 이런 뷰와 프레젠터의 관계를 유지하기 위해 보일러플레이트 코드를 적게 됩니다.
      (사용자 이벤트와 처리하는 로직이 많아질수록 Contract 인터페이스 안에 더 많은 함수를 추가해야 합니다.)
    - 프레젠터가 뷰와 강하게 연결되어 있어, 여전히 테스트 하기 어려운 구조입니다.

## **3) MVVM 패턴**

### 구조 및 작동 방식

<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/mvvm1.png">

위에서 알아본 MVP패턴에서의 단점을 보완하기 위해 MVVM 패턴을 살펴보면 좋을 것 같습니다. MVVM 패턴은 위의 모습과 같습니다. MVP 패턴과 유사하지만 한가지 차이점은 뷰모델과 뷰 사이가 데이터 바인딩으로 연결되어 뷰의 변경을 직접 요청하는 내용이 없어졌다는 것입니다.

각 요소에 대한 설명은 아래와 같습니다.

- Model: 애플리케이션의 데이터와 비즈니스 로직을 관리합니다. MVC 패턴의 Model과 동일한 역할을 합니다.
- View: 화면을 구성하고, ViewModel과 데이터 바인딩을 통해 상호작용합니다. 사용자 입력을 ViewModel에 전달하고, ViewModel로부터 데이터를 받아 UI를 업데이트합니다.
- ViewModel: View와 Model 사이의 중개자 역할을 합니다. Model의 데이터를 가공하여 View에 적합한 형태로 제공하고, View에서 발생한 이벤트를 처리하여 Model을 업데이트합니다. ViewModel은 View와 직접적인 참조 관계가 없어 의존성이 낮습니다.

MVVM 패턴에서는 직접 뷰를 변경하도록 요청하는 것이 아니라 뷰모델 내의 값을 observe(구독 혹은 관찰)함으로써 뷰가 능동적으로 변경될 수 있도록 합니다. 이를 위해 Databinding과 LiveData의 개념이 사용되게 됩니다.

### MVVM 패턴을 쉽게 적용하는 방법

1. databinding 이 가능하도록 설정 파일을 변경합니다. (app 모듈 gradle 파일에서 추가합니다)

   <img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/mvvm_code1.png">

2. AAC ViewModel을 상속받는 ViewModel 클래스를 생성합니다.
   그리고 변동에 대해서 관찰할 변수는 LiveData 를 사용하여 변동사항을 감지할 수 있도록 합니다.

   <img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/mvvm_code2.png">

3. 뷰에서 LiveData 값들을 observe 하도록 설정하여, 값의 변동을 능동적으로 감지하여 변경할 수 있도록 합니다.

   <img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/hogu59/images/mvvm_code3.png">


### 장단점

이러한 방식으로 우리는 MVVM 패턴의 코드를 어떻게 작성할 수 있는지 알아볼 수 있었습니다. 이번에는 MVVM 패턴을 사용할 때의 장단점을 알아봅시다.

1. 장점
    - View와 ViewModel 간의 의존성이 낮아 유지보수성과 확장성이 높아집니다
    - ViewModel은 View와 Model 모두에 대한 의존성이 낮아 단위 테스트가 용이합니다.
2. 단점
    - ViewModel 계층이 추가되면서 전체 코드 베이스가 복잡해질 수 있습니다.
    - ViewModel 객체가 추가되면서 메모리 사용량이 증가할 수 있습니다. 특히 양방향 데이터 바인딩을 많이 사용하면 성능에 저하가 생길 수 있습니다.

# **3. 패턴 비교 및 선택 가이드**

### 어느 상황에서 패턴을 적용할 때, 적합한지 알아보자 (When)

마지막 내용을 통해 MVVM 패턴이 항상 적합하다고 생각할 수 있습니다. 하지만 팀의 상황에 따라, 프로젝트의 규모에 따라 적합한 패턴은 달라질 수 있습니다. 사용자의 이벤트가 빈번하고 그에 따른 로직이 존재한다면 MVVM 패턴이 유용하겠지만, 앱의 로직이 단순하고 사용자와의 상호작용이 적다면 MVC 패턴으로 작성하는 것이 오히려 더 좋은 선택일 수 있습니다. 그 편이 더 빠른 시간 안에 개발을 가능하게 해줄 수 있기 때문입니다. 당신의 서비스와 당신의 팀의 상황을 고려하여 적절한 패턴을 적용해보시기 바라며 이만 글을 마치도록 하겠습니다.
