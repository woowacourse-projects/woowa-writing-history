---
author: "masonkimseoul"
generation: 6
level: "unclassified"
original_filename: "technical_writing.md"
source: "https://github.com/woowacourse/woowa-writing/blob/masonkimseoul/technical_writing.md"
source_path: "technical_writing.md"
---

# MySQL 인덱스 개론과 실습

내가 만든 서비스를 많은 사람들이 사용하는 것. 웹 서비스를 만드는 대부분의 개발자들이 공통적으로 소망하는 것이라고 꼽을 수 있겠다. 그런데 사용자가 요청한 정보를 한참 후에 보여준다면, 그런 서비스를 사람들이 사용해줄까? 데이터베이스 성능은 서비스의 성공을 결정짓는 중요한 요소 중 하나이다. 사용자의 요청이 빠르고 정확하게 처리되지 않는다면, 서비스는 경쟁력을 잃고 사용자 만족도 역시 떨어질 수밖에 없다. 특히, 웹 서비스가 점점 더 많은 데이터를 다루게 될수록 데이터베이스는 점점 더 느려질 수 있다. 이를 해결하기 위한 핵심 도구 중 하나가 바로 인덱스다.

인덱스는 책의 목차처럼 데이터베이스에서 원하는 정보를 더 빠르게 찾아낼 수 있게 해주는 중요한 역할을 한다. 대량의 데이터를 가진 테이블에서 특정 데이터를 조회하는 데 걸리는 시간을 줄여줌으로써, 인덱스는 데이터베이스 성능을 크게 향상시킬 수 있다. 하지만 모든 인덱스가 항상 이점만 제공하는 것은 아니다. 잘못된 인덱스 설계나 사용은 오히려 성능 저하를 야기할 수 있으며, 인덱스가 차지하는 저장 공간도 고려해야 한다. 따라서 인덱스의 원리와 활용 방법을 정확히 이해하는 것이 중요하다.

이번 글에서는 MySQL에서의 인덱스 개념을 시작으로, 인덱스를 실제로 적용하고 성능을 측정하는 실습까지 다룰 것이다. 인덱스의 종류와 작동 방식, 그리고 적절한 사용법을 이해함으로써 데이터베이스 최적화를 위한 기초를 다지고자 한다.

# 인덱스란?
위에서 서술하였듯이, 인덱스는 쉽게 말해 데이터베이스에서 사용하는 **색인**이다. 우리가 책에서 원하는 내용을 찾기 위해 목차를 사용하는 것처럼, 데이터베이스에서도 특정 데이터를 빠르게 찾기 위해 인덱스를 사용한다. 인덱스는 칼럼의 값과 해당 레코드가 저장된 주소를 Key-Value 형태로 저장하며, 데이터를 빠르게 탐색할 수 있도록 미리 정렬된 상태로 보관한다.

하지만 인덱스는 장점만 있는 것이 아니다. 데이터를 저장하거나 수정하는 작업(INSERT, UPDATE, DELETE)은 인덱스를 유지해야 하기 때문에, 그 성능이 어느 정도 희생된다. 반대로 데이터를 조회하는 작업(SELECT)은 인덱스를 사용하면 더 빠르게 처리된다. 결국, 인덱스는 조회 성능을 높이는 대신 저장 성능을 포기하는 트레이드오프를 동반하는 도구이다.

따라서 테이블에 인덱스를 추가할 때는 신중해야 한다. 테이블의 인덱스를 더 추가할 것인지 말 것인지는 데이터 저장 성능을 어느 정도까지 희생할 수 있는지, 그리고 읽기 성능을 얼마나 더 향상해야 하는지에 따라 결정된다. 만약 무분별하게 인덱스를 추가하면, 저장 성능이 현저히 떨어질 뿐만 아니라 인덱스 자체의 크기가 비대해져 역효과를 불러올 수 있다.

# B-Tree 인덱스
B-Tree 인덱스(Balanced-Tree Index)는 MySQL에서 가장 일반적으로 사용되는 인덱스 구조 중 하나이다. B-Tree는 데이터를 효율적으로 저장하고 빠르게 검색할 수 있도록 도와주는 트리 기반 인덱스로, B+-Tree나 B_-Tree와 같은 변형들도 존재한다. 이 인덱스는 칼럼의 원래 값을 변형시키지 않고 데이터를 관리하며, 항상 정렬된 상태를 유지한다는 점에서 큰 특징이 있다. 칼럼의 값 일부만을 잘라서 관리할 수는 있지만, 기본적으로 값 자체는 그대로 보존된다.

## 구조 및 특성

B-Tree 인덱스는 트리 구조로 되어 있으며, 루트 노드, 브랜치 노드, 그리고 리프 노드로 구성된다. 이 구조는 데이터를 빠르게 검색하기 위해 설계되었다. B-Tree의 리프 노드는 인덱스의 끝단에 위치하며, 각 리프 노드는 실 데이터를 찾기 위한 주솟값을 가지고 있다. 이 구조 덕분에 데이터베이스는 빠르게 특정 레코드를 찾아낼 수 있다.

B-Tree 인덱스의 주요 특성은 다음과 같다:

- 인덱스와 실 데이터는 따로 관리된다. 즉, 인덱스는 특정 데이터의 위치를 가리키는 역할을 할 뿐, 실제 데이터는 별도의 공간에 저장된다. 하지만 리프 노드는 항상 데이터 레코드로의 주솟값을 가지고 있어, 실 데이터를 찾아갈 수 있게 한다.
- 인덱스의 키 값은 정렬되어 있다. 하지만 실제 데이터는 정렬되지 않은 상태로 저장될 수 있다. 특히 InnoDB 테이블의 경우, 데이터는 프라이머리 키 순서로 클러스터링되어 디스크에 저장된다. 즉, 비슷한 값을 가진 데이터는 디스크 상에서도 최대한 가까운 위치에 저장된다.
- B-Tree 인덱스는 테이블의 키 칼럼만을 관리하므로, 나머지 칼럼을 읽기 위해서는 데이터 파일에서 해당 레코드를 추가로 찾아야 한다.

## B-Tree 인덱스 키 추가 및 삭제

B-Tree 인덱스는 데이터를 효율적으로 검색할 수 있지만, 인덱스 키를 추가하거나 삭제하는 작업은 상대적으로 비용이 더 많이 든다. 이 작업들은 데이터의 위치를 찾아 적절히 저장하거나 삭제해야 하며, 때로는 트리의 구조를 변경해야 하기 때문이다. B-Tree 인덱스에서 키를 추가하거나 삭제하는 작업의 특성은 다음과 같다.

### 인덱스 키 추가

B-Tree에 새로운 키 값을 추가할 때는, 먼저 키 값이 저장될 적절한 위치를 찾아야 한다. 이 과정은 B-Tree 상의 위치를 탐색하는 작업으로 시작된다. 저장할 위치가 결정되면, 해당 리프 노드에 레코드의 키 값과 주소 정보를 저장한다. 그러나 리프 노드가 꽉 차 있는 경우, 리프 노드가 분리되어 새로운 노드가 생성되고, 이로 인해 상위의 브랜치 노드까지 영향을 미칠 수 있다. 이 과정 때문에 쓰기 작업(INSERT, UPDATE)이 상대적으로 더 많은 비용을 요구하게 된다.

- 쓰기 작업에 대한 영향: 인덱스 키 추가 작업이 테이블의 칼럼 수, 칼럼 크기, 인덱스 칼럼의 특성 등에 따라 영향을 받는다. 대략적인 비교로, 테이블에 레코드를 추가하는 비용을 1이라 할 때, 인덱스에 키를 추가하는 비용은 1.5배 정도 더 크다. 따라서, 테이블에 인덱스가 3개 있는 경우, 인덱스를 관리하는 총 비용은 5.5배 정도로 예상할 수 있다.
- 디스크 I/O의 비중: 인덱스 추가 작업의 대부분은 디스크에서 인덱스 페이지를 읽고 쓰는 시간이 차지한다. CPU와 메모리의 작업보다는 디스크 I/O 비용이 훨씬 크다.
- **스토리지 엔진에 따른 차이**:
    - MyISAM이나 MEMORY 엔진에서는 INSERT 문이 실행될 때, 새로운 키 값이 B-Tree에 즉시 반영된다.
    - InnoDB는 경우에 따라 키 추가 작업을 지연시켜 처리할 수 있다. 하지만 프라이머리 키나 유니크 인덱스는 중복 체크가 필요하므로, 즉시 처리된다.

### 인덱스 키 삭제

인덱스에서 키를 삭제할 때는 해당 키 값을 저장하고 있는 리프 노드를 찾아 삭제 마킹을 한다. 단순히 값을 제거하는 것이 아니라, 삭제 마크를 남겨두고, 그 공간을 방치하거나 재활용할 수 있다. 이 작업 역시 디스크에 쓰기 작업을 요구한다.

- 지연 처리: MySQL 5.5 이상의 InnoDB에서는 인덱스 키 삭제 또한 버퍼링되어 지연 처리될 수 있다. 이 과정은 MySQL 서버 내부에서 자동으로 처리되므로, 사용자에게는 특별한 영향이 없다.

### 인덱스 키 변경

B-Tree 인덱스에서 인덱스 키 값이 변경될 경우, 단순히 값을 변경할 수는 없다. 인덱스 키 값에 따라 저장 위치가 결정되므로, 변경이 필요한 경우에는 기존 키를 삭제한 후, 새로운 키 값을 추가하는 방식으로 처리된다. 이 작업은 InnoDB에서 체인지 버퍼를 활용해 지연 처리할 수 있다.

### 인덱스 키 검색

B-Tree 인덱스의 키 검색은 SELECT뿐만 아니라, UPDATE나 DELETE 작업 시에도 진행된다. B-Tree 인덱스는 다음과 같은 조건에 유리한 검색을 제공한다:

- 부등호 비교 조건 (`<`, `>`, `<=`, `>=`)
- 값의 앞부분 일치 조건
- 값의 완전 일치 조건

그러나 키 값의 뒷부분만으로는 검색할 수 없으며, 키 값이 변형된 경우에도 B-Tree 인덱스를 활용할 수 없다. 예를 들어, 함수나 연산을 통해 변형된 값을 기준으로 정렬하거나 검색하는 경우에는 B-Tree 인덱스의 빠른 검색 기능을 사용할 수 없으며, 이로 인해 성능 저하가 발생할 수 있다.

InnoDB에서는 인덱스 검색 시 레코드 락이나 갭 락을 사용해, 검색한 인덱스를 잠근 후 해당 레코드에 접근한다. 만약 적절한 인덱스가 없을 경우, 불필요하게 많은 레코드를 잠그는 상황이 발생할 수 있다. 따라서 효율적인 인덱스 설계가 중요하다. 잘못된 인덱스 설계는 데이터베이스 성능에 큰 영향을 미칠 수 있다.

## B-Tree 인덱스 사용에 영향을 미치는 요소

B-Tree 인덱스의 성능은 여러 가지 요인에 의해 영향을 받는다. 여기서는 인덱스를 구성하는 칼럼의 크기, 레코드의 수, 유니크한 인덱스 키 값의 개수 등이 B-Tree 인덱스 사용에 어떻게 영향을 미치는지 살펴본다.

### 인덱스 키 값의 크기

InnoDB가 데이터를 저장하는 기본 단위는 페이지(Page)라고 불리며, 디스크에서 데이터를 읽고 쓰는 최소 단위이기도 하다. 인덱스 또한 페이지 단위로 관리되며, 루트, 브랜치, 리프 노드는 모두 페이지로 나뉜다. MySQL의 InnoDB는 페이지 크기를 기본적으로 16KB로 사용하지만, 시스템 변수인 `innodb_page_size`로 4KB에서 16KB 사이로 설정할 수 있다.

- B-Tree의 `B`는 Binary가 아니므로 자식 노드의 수는 가변적이다. 인덱스 페이지 크기와 키 값의 크기에 따라 결정된다.
    
- 예를 들어, 인덱스 키 값이 16바이트일 때, 페이지에 저장될 수 있는 자식 노드의 수는 585개다. 반면, 키 값이 32바이트로 커지면, 자식 노드의 수는 372개로 줄어든다.
    
    결과적으로, 키 값이 커질수록:
    
    1. 한 번에 읽어올 수 있는 레코드의 양이 줄어들고,
    2. 인덱스 크기가 커져서 메모리 캐시에 저장할 수 있는 레코드 수가 줄어들게 된다.

### B-Tree 깊이

B-Tree 인덱스의 깊이는 검색 성능에 큰 영향을 미친다. B-Tree가 깊어질수록 랜덤 디스크 읽기가 많아지기 때문에 탐색 시간이 느려질 수 있다. 깊이가 깊어지는 것은 주로 인덱스 키 값의 크기와 레코드 수에 따라 달라진다.

- 예를 들어, 깊이가 3이고, 인덱스 키 값이 16바이트라면 최대 585³개의 키 값을 저장할 수 있다. 하지만 키 값이 32바이트로 늘어나면 최대 372³개의 키 값만 저장 가능하다.
- 깊이가 깊어질수록 디스크 읽기 비용이 증가하므로, 인덱스 키 값을 작게 유지하는 것이 성능에 유리하다.
- 대부분의 대용량 데이터베이스에서도 B-Tree 깊이는 5 이상 깊어지기 어렵다.

### 선택도(Selectivity) 및 기수성(Cardinality)

인덱스의 선택도(Selectivity)는 전체 인덱스 키 값 중 유니크한 값의 비율을 의미하며, 기수성(Cardinality)이라고도 부른다. 선택도가 높을수록 검색 대상이 줄어들기 때문에 인덱스의 효율성이 증가한다.

- 예를 들어, 1만 건의 레코드 중에서 `country='KOREA'`라는 조건으로 검색할 때, `country`의 유니크 값이 10개인 경우, `KOREA`에 해당하는 레코드는 1,000개다. 이 중 `city='SEOUL'`과 일치하는 레코드가 1개라면, 나머지 999개의 불필요한 레코드를 읽게 된다.
- 반면 `country`의 유니크 값이 1,000개인 경우, `KOREA`에 해당하는 레코드는 10개로 줄어들고, 불필요한 레코드는 9개가 된다.

따라서, 유니크한 값이 많은 칼럼에 인덱스를 설정하는 것이 성능에 유리하다. 선택도가 낮은 인덱스는 검색 효율성이 떨어질 수 있지만, 정렬이나 그루핑 등의 작업에서는 여전히 유용할 수 있으므로, 인덱스는 목적에 맞게 설계해야 한다.

### 읽어야 하는 레코드의 건수

인덱스를 사용하여 읽어야 하는 레코드 수는 성능에 중요한 영향을 미친다. 일반적으로 인덱스를 통해 레코드 1건을 읽는 비용은 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 더 많은 비용이 발생한다.

- 옵티마이저의 판단 기준: 인덱스를 사용하여 읽어야 하는 레코드 수가 전체 테이블의 20~25%를 초과하는 경우, 테이블을 직접 읽는 것이 더 효율적이다.
- 이와 같은 경우에는 인덱스를 사용하도록 강제하는 힌트도 유효하지 않으며, MySQL의 옵티마이저는 이러한 상황에서 테이블을 직접 읽는 방법을 선택한다.

### 인덱스 레인지 스캔

인덱스 레인지 스캔은 가장 일반적인 인덱스 접근 방식으로, 검색할 범위가 결정되었을 때 사용된다. 루트 노드에서 탐색을 시작해 브랜치 노드를 거쳐 리프 노드에 도달하며, 스캔할 시작 위치를 찾으면 범위 내의 인덱스를 순차적으로 읽는다. 인덱스만 읽는 경우도 있지만, 데이터 파일의 레코드를 함께 읽어야 하는 경우도 있다. 인덱스 자체는 정렬되어 있으므로 순차적으로 읽기만 하면 정렬된 결과를 얻을 수 있다. 인덱스 스캔 과정에서는 레코드 단위로 랜덤 I/O가 발생할 수 있다.

과정은 다음과 같다:

1. **인덱스 탐색**: 조건에 맞는 값을 찾아 인덱스를 탐색한다.
2. **인덱스 스캔**: 탐색한 위치에서 필요한 만큼 순차적으로 인덱스를 읽는다.
3. **레코드 읽기**: 인덱스 키와 레코드 주소를 이용해 해당 레코드가 저장된 페이지를 가져와 데이터를 읽는다.

### 인덱스 풀 스캔

인덱스 풀 스캔은 인덱스를 처음부터 끝까지 모두 읽는 방식이다. 쿼리 조건에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닐 때 사용되며, 인덱스에 명시된 칼럼만으로 쿼리를 처리할 수 있을 때 주로 쓰인다. 데이터 레코드까지 읽어야 하는 경우엔 사용되지 않는다. 이 방식은 인덱스의 처음이나 끝에서 시작하여 리프 노드를 순차적으로 스캔한다. 테이블 풀 스캔보다는 효율적이지만, 인덱스 레인지 스캔보다는 효율이 떨어진다.

### 루스 인덱스 스캔

루스 인덱스 스캔은 중간에 불필요한 인덱스 키 값을 건너뛰고 필요한 값만 읽는 방식이다. 주로 `GROUP BY`나 `MIN()`, `MAX()` 같은 쿼리에서 사용된다. 예를 들어, (dept_no, emp_no)로 구성된 인덱스가 있을 때, `dept_no` 그룹별 첫 번째 `emp_no` 값만 읽으면 된다. 정렬된 상태이므로 첫 번째 값이 `MIN` 값임을 보장할 수 있기 때문이다.

### 인덱스 스킵 스캔

인덱스 스킵 스캔은 다중 칼럼 인덱스에서 첫 번째 칼럼을 건너뛰고 두 번째 칼럼 이후로 검색할 수 있는 방식이다. MySQL 8.0부터 도입된 기능으로, 첫 번째 칼럼에 조건이 없어도 두 번째 칼럼을 기준으로 인덱스를 활용할 수 있게 되었다. 이 기능은 특정 상황에서 옵티마이저가 선행 칼럼의 유니크한 값들을 조회한 후, 그 값을 기준으로 다시 검색을 수행하는 방식으로 동작한다.

### 비교 조건의 종류와 효율성

`SELECT * FROM dept_emp WHERE dept_no='d002' AND emp_no >= 10114;`

이 쿼리에서 두 가지 인덱스 케이스를 비교해 볼 수 있다:

- 케이스 A: `INDEX (dept_no, emp_no)`
- 케이스 B: `INDEX (emp_no, dept_no)`

케이스 A의 경우, `dept_no`가 'd002'인 레코드를 먼저 찾고, 그중에서 `emp_no`가 10114 이상인 레코드를 찾는다. 반면에 케이스 B에서는 `emp_no`가 10114 이상인 레코드를 모두 읽은 후, 그중에서 `dept_no`가 'd002'인 레코드를 찾아야 하므로 불필요한 레코드 읽기가 발생한다.

이때 인덱스 조건을 작업 범위 결정 조건과 필터링 조건으로 나눌 수 있다. 케이스 A에서 `dept_no`와 `emp_no`는 작업 범위 결정 조건이며, 케이스 B에서는 `emp_no`가 작업 범위 결정 조건, `dept_no`는 필터링 조건이다. 작업 범위 결정 조건이 많을수록 쿼리 성능이 향상되지만, 필터링 조건이 많다고 해서 성능이 크게 개선되지는 않는다.

B-Tree 인덱스는 왼쪽 값에 기준하여 오른쪽 값이 정렬되는 구조이다. 하나의 칼럼을 기준으로 검색하더라도, 왼쪽 칼럼 값이 없으면 인덱스 레인지 스캔이 불가능하다. 다중 칼럼 인덱스에서 첫 번째 칼럼의 값을 모르면 레인지 스캔이 불가능하다는 점을 유의해야 한다.

### 가용성과 효율성 판단

B-Tree 인덱스에서 작업 범위 결정 조건으로 사용할 수 없는 경우는 다음과 같다:

1. NOT-EQUAL 조건으로 비교된 경우(`<>`, `NOT IN`, `NOT BETWEEN`, `IS NOT NULL`)
    - MySQL에서는 NULL 값도 인덱스에 저장되기 때문에 NULL은 작업 범위 결정 조건으로 사용 가능하다.
2. `LIKE ‘%??’` 형태로 문자열 패턴이 뒤쪽에서 일치하는 경우
3. 스토어드 함수나 다른 연산자를 사용해 인덱스 칼럼이 변형된 경우
4. NON-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
5. 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
6. 문자열 데이터 타입의 콜레이션이 다른 경우

다음과 같은 인덱스가 있다고 가정할 때:

`INDEX ix_test (column_1, column_2, column_3, ..., column_n)`

1. 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
    - `column_1`에 대한 조건이 없을 때
    - `column_1`이 인덱스 사용 불가 조건 중 하나에 해당될 때
2. 작업 범위 결정 조건으로 인덱스를 사용할 수 있는 경우(2 < i < n)
    - `column_1`에서 `column(i-1)`까지 동등 비교(= 또는 `IN`)가 사용될 때
    - `column_i`에 대해 다음 연산자 중 하나로 비교될 때
        1. 동등 비교(= 또는 `IN`)
        2. 비교 연산자(`>`, `<`)
        3. `LIKE`로 좌측 일치 패턴(LIKE ‘메이슨%’)

위 조건을 만족하는 쿼리는 `column_1`부터 `column_i`까지 작업 범위 결정 조건으로 사용되고, `column_(i+1)`부터 `column_n`까지는 체크 조건으로 사용된다.

## 실습
### 총대마켓
총대마켓은 원하는 상품을 함께 구매하고 싶은 사람을 모아 공동구매를 진행하거나, 다른 공동구매에 참여하여 저렴하게 상품을 구매할 수 있는 플랫폼이다.

### 테이블 구조
![image](https://github.com/user-attachments/assets/0f90d5f8-0436-4769-88ab-cf586a34226b)
다음과 같이 총 4개의 테이블을 가지고 있다.
- 사용자 정보를 담고 있는 사용자 테이블(Member), 공동구매 모집 게시글을 의미하는 공모 테이블(Offering), 각 공동구매에 참여한 사용자의 정보를 담고 있는 공모_사용자 테이블(Offering_Member), 각 공동구매에서 작성한 댓글에 대한 정보를 담고 있는 댓글 테이블(Comment)로 총 4개의 테이블이 존재한다.
이 중 가장 많이 조회가 일어날 것으로 예상되는 Offering 테이블의 쿼리를 살펴보겠다.
### 성능이 좋지 않은 쿼리
```
SELECT o
FROM OfferingEntity o
WHERE (o.offeringStatus = 'IMMINENT')
    AND (o.meetingDate > :lastMeetingDate OR (o.meetingDate = :lastMeetingDate AND o.id < :lastId))
    AND (:keyword IS NULL OR o.title LIKE :%keyword% OR o.meetingAddress LIKE :%keyword%)
ORDER BY o.meetingDate ASC, o.id DESC
```
- findImminentOfferingsWithKeyword 메서드
이 쿼리는 위 메서드를 위해 작성한 JPQL이다.
- 문제점
1. `OR`절로 인해 인덱스 사용 불가
2. 검색어의 경우 앞뒤로 `%`연산자를 사용하느라 인덱스 사용 불가

- 해결방안
1. 과도한 `OR`절을 줄이기 위해 검색어 키워드가 필요한 쿼리와 그렇지 않은 쿼리를 분리하였다.  
2. 검색 엔진을 사용하거나 전문 검색 인덱스를 사용하는 것이 이상적이지만, 아직은 그에 대한 적용을 하지 않고 일부만 해결하려고 한다. 우선적으로 앞부분에 붙은 `%`연산자만 제거하여 인덱스를 사용할 수 있도록 하였다.

- 적용한 인덱스
1. (meeting_date, id desc)
2. (meeting_address, offering_status)
3. (title, offering_status)
