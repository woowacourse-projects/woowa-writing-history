---
author: "llqqssttyy"
generation: 6
level: "unclassified"
original_filename: "Technical.md"
source: "https://github.com/woowacourse/woowa-writing/blob/llqqssttyy/Technical.md"
source_path: "Technical.md"
---

# 캐시 관리 전략, 왜 필요하고 어떻게 적용할까?

크루루 프론트팀은 개발과 프로덕션 서버를 모두 S3와 CloudFront를 통해 배포합니다.

그런데 어느 날 개발 서버 업데이트 후 팀원들이 이전 버전의 사이트를 보게 되는 문제를 겪었고, 이는 브라우저와 CDN 캐싱이 원인이라는 것을 알게 되었습니다.

캐싱이 여러 레이어에서 작동하며 업데이트가 즉시 반영되지 않는 부작용이 발생한 것입니다. 따라서 캐싱을 효과적으로 관리하는 방법을 조사했습니다.

이 글에서는 캐시의 필요성, 상황별 설정 방법, 그리고 S3와 CloudFront 환경에서 실질적으로 사용할 수 있는 캐시 무효화와 만료 전략에 대해 다뤄보겠습니다.

<br/>

## 웹 캐시, 왜 쓰나요?

> 웹 캐시(Cache)는 웹 서비스의 성능을 최적화하기 위해 클라이언트와 서버 간의 요청을 줄이고, 불필요한 리소스 로드를 방지하는 중요한 기술입니다.

<br/>

### 웹 캐시란 무엇인가?

웹 캐시는 **클라이언트(브라우저), 서버, 또는 콘텐츠 전송 네트워크(CDN)와 같은 중간 캐시 계층에 자원을 임시로 저장해 두는 메커니즘**입니다.(이 글에서 서버 계층은 다루지 않습니다.)

쉽게 말해, 웹 캐시는 이전에 서버에서 요청했던 자원(HTML, CSS, JavaScript, 이미지 등)을 기억했다가 동일한 자원을 다시 요청할 때 저장된 버전을 제공함으로써 로딩 속도를 높이기 위해 사용합니다.

캐시가 적용된 웹서비스에서는 다음과 같은 절차를 통해 서버로의 요청 수가 줄어듭니다.

1. **초기 요청 (Initial Request)**: 사용자가 웹 페이지에 처음 접속할 때, 브라우저는 서버에 필요한 자원들을 요청합니다. 이때 서버는 요청에 응답하고, 브라우저는 받은 자원을 캐시에 저장해 둡니다.

2. **캐시된 자원 확인 (Cache Check)**: 이후 같은 자원을 요청할 때, 브라우저는 먼저 캐시에 해당 자원이 있는지 확인합니다.

3. **캐시 적중 (Cache Hit)**: 캐시에서 요청한 자원을 찾을 수 있다면, 서버에 재요청하지 않고 캐시된 자원을 반환합니다. 이로써 불필요한 네트워크 통신을 방지하고 로딩 속도를 빠르게 할 수 있습니다.

4. **캐시 미스 (Cache Miss)**: 만약 캐시에 자원이 없다면, 브라우저는 서버로 새로운 요청을 보내 자원을 받아오고, 받은 자원을 캐시에 저장해 이후에 사용할 수 있도록 합니다.

<br/>

만약 CloudFront와 S3로 배포했다면, CloudFront(CDN)의 캐싱을 이용할 수 있습니다. 매커니즘음 아래 그림과 같습니다.

![](https://github.com/llqqssttyy/woowa-writing/blob/technical/cloudfront_cache.png?raw=true)

<br/>

### 왜 웹 캐시가 중요한가?

웹 캐시는 성능과 사용자 경험(UX)을 향상시키기 위해 반드시 필요합니다.

웹 캐시를 사용하면 클라이언트와 서버 간의 요청/응답 사이클을 줄여주어 로딩 시간이 단축되기 때문입니다.

<br/>

네트워크 요청 대신 필요한 자원을 캐시에서 바로 불러오면 페이지 로드 성능을 크게 향상시킬 수 있습니다.

또한 같은 자원을 반복적으로 요청하지 않기 때문에 서버에 가해지는 부하가 줄어들어 서비스 운영에도 이점이 있습니다.

<br/>

## 웹 캐시 관리 전략

웹 캐시를 효과적으로 관리하기 위해서는 다양한 전략을 이해하고, 서비스 특성에 맞는 방법을 적용해야 합니다.

아래에서는 대표적인 캐시 관리 전략을 무효화 계층, 구체적인 방법, 프론트엔드 예시 코드, 그리고 각각의 장단점 및 고려 사항을 중심으로 설명하겠습니다.

### 1. 캐시 무효화 계층

캐시 무효화는 캐시에 저장된 데이터를 더 이상 유효하지 않다고 간주하고, 이를 제거하거나 업데이트하는 작업을 말합니다.

캐시 무효화는 크게 다음 세 가지 계층에서 이루어질 수 있습니다:

- **클라이언트 측 (브라우저 캐시)**: 클라이언트의 브라우저가 관리하는 캐시로, 주로 자바스크립트 파일, CSS 파일, 이미지 등의 정적 자원을 저장합니다.

- **프록시 캐시 (CDN 등)**: 클라이언트와 서버 사이에 위치한 캐시 계층으로, 클라이언트 요청을 대신 받아 캐시된 데이터를 전달하거나, 서버로부터 데이터를 받아 캐시에 저장 후 전달합니다.

- **서버 측 캐시 (애플리케이션 서버 캐시)**: 서버 내부의 캐시 저장소(메모리, Redis 등)에 데이터를 저장하여 데이터베이스 요청을 줄이고 성능을 최적화하는 방식입니다.

<br/>

### 2. 캐시 관리 전략

#### 시간 기반 캐시 무효화 (Time-based Invalidation)

자원에 특정 유효 기간(TTL, Time-To-Live)을 설정하여, 기간이 만료되면 캐시가 자동으로 무효화되도록 하는 전략입니다.

`Cache-Control` 및 `Expires` 헤더를 사용하여 자원의 유효 기간을 정의합니다.

- `Cache-Control` 헤더에 `max-age` 값을 설정하여, **자원이 유효한 시간을 지정**합니다.

<br/>

```jsx
useEffect(() => {
  fetch('https://api.example.com/data', {
    // Cache-Control: max-age=3600 (1시간 동안 캐시를 유지)
    headers: { 'Cache-Control': 'max-age=3600' },
  })
    .then((response) => response.json())
    .then((data) => setData(data));
}, []);
```

<br/>

- 구현이 간단하고, 시간 기반으로 캐시를 관리할 수 있어 효율적입니다.
- 일정한 주기로 업데이트되는 데이터에 적합합니다.
- 고정된 TTL 값으로 인해 자주 변경되는 데이터에 부적합할 수 있습니다.

<br/>

#### 버전 관리 기반 캐시 무효화 (Version-based Invalidation)

자원의 URL이나 파일 이름에 버전을 포함시켜, 자원 업데이트 시 캐시된 데이터를 무효화하고 새로운 버전의 데이터를 캐싱하는 전략입니다. 주로 파일의 해시값을 사용합니다.

- 파일 빌드 시 해시값을 붙여 자원의 이름을 변경합니다. 예를 들어, app.js → app.12345.js.
- 서버 응답 헤더에서 ETag를 활용하여 파일 버전을 관리하고, 버전이 변경될 때 캐시를 무효화합니다.

<br/>

```javascript
module.exports = {
  output: {
    filename: 'bundle.[contenthash].js',
  },
};
```

<br/>

- 자원이 변경될 때마다 캐시를 자동으로 무효화하여 최신 데이터를 보장할 수 있습니다.
- 브라우저가 캐시된 파일을 효율적으로 관리할 수 있습니다.
- 매번 자원 파일의 이름이 변경되므로, 이를 참조하는 HTML 파일의 업데이트가 필요하지만, 번들러를 사용한다면 자동으로 갱신됩니다.

#### 수동 캐시 무효화 (Manual Invalidation)

개발자 또는 관리자에 의해 캐시를 수동으로 무효화하는 전략입니다.

자원의 변경 사항이 있을 때 수동으로 캐시를 비우거나, 서버에 `Cache-Control` 헤더로 `no-cache`, `no-store`를 설정하여 캐시를 사용하지 않도록 합니다.

- 캐시 무효화 시점을 개발자가 직접 관리합니다.

<br/>

자원이 변경된 경우, CDN에서 제공하는 API를 통해 특정 자원의 캐시를 강제로 삭제(Purge)합니다.

<br/>

```javascript
// 예시: Cloudflare API를 통해 특정 URL의 캐시 무효합니다.
fetch('https://api.cloudflare.com/client/v4/zones/your-zone-id/purge_cache', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    Authorization: 'Bearer your-api-key',
  },
  body: JSON.stringify({ files: ['https://example.com/app.js'] }),
});
```

<br/>

- 캐시 무효화 시점을 정확히 통제할 수 있어, 중요한 데이터 변경 시 유용합니다.
- 캐시가 잘못된 경우 즉시 수정이 가능합니다.
- 자동화되지 않아 관리 비용이 증가할 수 있으며, 수동 무효화 시점이 적절하지 않으면 데이터 불일치가 발생할 수 있습니다.
- 인프라나 API를 통해 캐시 무효화를 해야 하므로 추가적인 작업이 필요합니다.

<br/>

#### 조건부 요청 기반 캐시 무효화 (Conditional Requests)

클라이언트가 서버에 자원이 변경되었는지 확인한 후, 변경되었을 때만 새 데이터를 요청하는 방식입니다.

ETag나 Last-Modified 헤더를 사용하여 자원의 변경 여부를 판단합니다.

- 서버가 응답 시 ETag(파일 버전 정보) 또는 Last-Modified(마지막 수정 시간) 값을 헤더에 포함하여 전달합니다.
- 클라이언트가 다시 요청할 때 해당 값을 If-None-Match 또는 If-Modified-Since 헤더에 포함하여 서버에 전송합니다.
- 서버는 자원이 변경되지 않았을 경우 304 Not Modified 응답을 보내고, 클라이언트는 캐시된 자원을 사용합니다.

<br/>

```javascript
fetch('https://api.example.com/data', {
  headers: { 'If-None-Match': 'W/"12345"' },
})
  .then((response) => {
    if (response.status === 304) {
      // 데이터가 변경되지 않음: 캐시된 데이터 사용
    } else {
      return response.json();
    }
  })
  .then((data) => setData(data));
```

<br/>

- 자원이 변경되지 않은 경우 불필요한 데이터 전송을 막아, 네트워크 비용 절감할 수 있습니다.
- 서버와 클라이언트 간 데이터 동기화가 효율적으로 이루어집니다.
- 서버에서 ETag 또는 Last-Modified를 정확하게 관리해야 하며, 복잡한 구현이 필요합니다.

<br/>

### 3. 캐시 전략 도입 시 고려할 점

캐시 전략의 선택은 **데이터의 변경 빈도**와 **일관성 요구사항**에 따라 달라집니다.

정적 자원(이미지, 스타일시트 등)에는 **시간 기반 캐시 무효화**가 적합하며, 주기적인 업데이트가 필요한 데이터에는 **조건부 요청 기반 캐시**가 유리할 수 있습니다. 자주 변경되는 데이터에는 **버전 관리 기반 캐시**를 적용하여, 데이터 일관성을 보장하는 것이 중요합니다.

이처럼 개발 환경과 배포 전략에 따라 적절한 캐시 전략을 선택해야 합니다.

예를 들어, 배포 시마다 자원이 변경되는 경우 버전 관리 기반 캐시가 적합하고, 변경 빈도가 낮은 정적 콘텐츠는 시간 기반 캐시를 사용할 수 있습니다.

핵심은 성능 최적화와 데이터 일관성의 균형을 맞추는 것입니다.

캐시를 오래 유지하면 성능은 향상되지만 데이터 일관성이 낮아질 수 있기 때문에 서비스 특성에 맞는 TTL 및 캐시 무효화 전략을 수립해야 합니다.

이러한 캐시 관리 전략들을 이해하고 적절히 적용하면, 성능 최적화와 데이터 일관성 유지라는 두 가지 목표를 동시에 달성할 수 있습니다.

<br/>

## 크루루의 캐시 관리 전략

### 들어가기 전에

크루루 팀은 웹사이트 성능을 최적화하고 사용자 경험을 개선하기 위해 **리소스 유형별로 세분화된 캐싱 정책**을 적용하고 있습니다.

현재 크루루의 프론트엔드 애플리케이션은 AWS S3 Bucket을 Origin으로 사용하며, CloudFront(CDN)가 이를 캐싱하여 사용자에게 리소스를 전달하는 구조로 이루어져 있습니다.

따라서 **브라우저 캐시**와 **CDN 캐시**를 동시에 관리해야 했습니다.

### 리소스 별 캐싱 설정

| 구분          | 브라우저 캐시 | CDN 캐시     | 비고                                                          |
| ------------- | ------------- | ------------ | ------------------------------------------------------------- |
| HTML          | 0             | 1년          | Cache invalidation 활용 여부에 따라 CDN 캐시 기한을 조정 필요 |
| CSS/JS        | 1년           | 1년          | 파일명을 이용한 캐시 버스팅 활용                              |
| Image         | 1년           | 1년          | 파일명을 이용한 캐시 버스팅 활용                              |
| Font          | 1년           | 1년          |                                                               |
| Etc (Default) | 1일           | (기본값 1일) |                                                               |

- **HTML 리소스**: 항상 최신 리소스를 제공하기 위해 브라우저 캐시는 max-age=0으로 설정하고, CDN은 최대 1년 동안 캐싱되도록 설정했습니다. index.html에 변경이 있을 경우 cd 과정에서 CloudFront의 캐시를 무효화 해주는 과정을 거치므로 사용자는 최신 버전의 index.html을 볼 수 있습니다.

- **CSS/JS 및 이미지 리소스**: 파일명에 해시 값을 추가하여 캐시 버스팅을 활용하고, 브라우저와 CDN 캐시 모두 최대 1년 동안 캐시를 유지합니다.

- **폰트 리소스**: 변경 가능성이 희박한 리소스라 1년동안 캐시를 유지하도록 설정했습니다.

- **기타 리소스**: 이미지와 같은 기타 리소스는 기본 캐싱 설정인 1일동안 유지됩니다.

<br/>

### 캐시 정책 적용 방법

위와 같은 캐시 정책을 바탕으로 CloudFront의 Function을 이용해 요청 별로 `Cache-Control` 헤더를 동적으로 적용하도록 처리했습니다. 이렇게 하면 다양한 리소스 유형에 유연하게 대응할 수 있습니다.

<br/>

```
// pseudo code

// 리소스에 대한 기본 캐시 설정 정의
기본 브라우저 캐시 기간을 1일로 설정
기본 CDN 캐시 기간을 1일로 설정

// 리소스 유형에 따른 캐시 설정 결정
만약 리소스가 HTML이라면
    브라우저 캐시를 0으로 설정 (캐싱 없음)
    CDN 캐시를 1년으로 설정
    // 목적: HTML은 항상 최신 버전을 제공하되 CDN에서는 오랫동안 캐싱 유지

그 외에 리소스가 CSS 또는 JS라면
    브라우저 캐시를 1년으로 설정
    CDN 캐시를 1년으로 설정
    // 목적: 파일명 해싱을 이용하여 장기 캐싱하고, 업데이트는 해싱을 통해 관리

그 외에 리소스가 이미지라면
    브라우저 캐시를 1년으로 설정
    CDN 캐시를 1년으로 설정
    // 목적: 업데이트 빈도가 낮으므로 장기 캐싱

그 외에 리소스가 폰트라면
    브라우저 캐시를 1년으로 설정
    CDN 캐시를 1년으로 설정
    // 목적: 폰트 파일은 거의 변경되지 않으므로 장기 캐싱

그 외 (기본 설정)
    브라우저 캐시를 1일로 설정
    CDN 캐시를 1일로 설정
    // 목적: 기타 리소스는 짧은 기간 동안만 기본 캐싱

// 동적으로 리소스 헤더에 캐시 설정 적용
브라우저 및 CDN 캐시 기간을 포함한 Cache-Control 헤더 설정
캐시 설정이 적용된 요청을 반환
```

<br/>

이러한 정책을 CloudFront의 Function을 사용해 구현하게 된 결정엔 몇 가지 고려사항도 있습니다.

1. **CloudFront Function의 실행 비용**: CloudFront Function은 호출 건당 비용이 발생하므로, 캐시 설정을 적절하게 유지하여 불필요한 캐시 무효화를 방지하고, 서버 부하를 최소화해야 합니다.

2. **응답 헤더 정책 제한**: 현 프로젝트 환경에서는 CloudFront의 응답 헤더 정책을 여러 개 운영하기 어렵기 때문에, 하나의 Function으로 다양한 리소스에 대한 캐시 정책을 관리하는 것이 중요합니다.

<br/>

이로써 사용자에게 최신 콘텐츠를 빠르고 안정적으로 제공할 수 있는 캐싱 정책을 반영할 수 있었습니다.

## 마무리

이번 글에서는 웹 캐시의 개념과 필요성, 그리고 크루루의 캐싱 정책을 설정하고 CloudFront Function을 통해 이를 구현한 방법을 소개했습니다.

크루루에 캐싱 정책을 설정하고 invalidation하는 과정에서 캐시의 다양한 적용 방식과 고려 사항을 깊이 있게 배울 수 있었습니다.
특히 이러한 정책이 **서비스 요구사항에 따라 유연하게 조정될 수 있음**을 깨달았습니다.

앞으로도 변화하는 서비스 환경에 맞추어 최적의 성능을 유지할 수 있도록 지속적으로 캐시 전략을 모니터링하고 개선해 나가겠습니다.
