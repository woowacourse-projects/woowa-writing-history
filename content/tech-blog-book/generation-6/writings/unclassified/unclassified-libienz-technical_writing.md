---
author: "libienz"
generation: 6
level: "unclassified"
original_filename: "technical_writing.md"
source: "https://github.com/woowacourse/woowa-writing/blob/libienz/technical_writing.md"
source_path: "technical_writing.md"
---


# DB Replication 가이드 

## 0. 서론

### 0.1 서비스는 확장성과 고가용성을 갖추어야 한다. 
애플리케이션이 성공적으로 성장하면서 더 많은 사용자를 맞이하게 되면, 시스템 성능과 안정성 유지가 중요한 과제가 됩니다. 특히 많은 요청을 처리해야 하는 웹 애플리케이션에서는 확장성과 고가용성 확보가 필수적입니다. 하지만 이러한 목표를 달성하는 것은 쉽지 않으며, 특히 병목이 발생할 수 있는 데이터베이스(DB)는 종종 성능 저하의 원인이 됩니다.  

### 0.2 병목 지점으로서의 데이터베이스
웹 애플리케이션에서 데이터베이스는 필수적인 구성 요소지만, 트래픽 증가와 복잡한 데이터 처리 요구를 제대로 대응하지 못할 경우 성능이 급격히 저하될 수 있습니다. 이로 인해 사용자 경험은 악화될 수 있으며, 최악의 경우 사용자가 이탈할 수 있습니다. 따라서 데이터베이스의 병목 현상을 해결하고, 애플리케이션의 성능을 유지하는 것은 곧, 성공적인 프로젝트 운영을 위한 핵심 과제입니다.

### 0.3 데이터베이스 확장성과 고가용성을 위한 기술 - DB Replication
데이터베이스 확장성과 고가용성을 달성하는 방법 중 하나가 바로 **DB Replication**입니다. DB Replication은 데이터를 여러 데이터베이스 인스턴스에 복제하여 읽기 성능을 향상시키고, 장애 발생 시 시스템의 가용성을 보장하는 기술입니다. 

DB Replication을 통해 여러분은 데이터베이스 병목을 해소하고, 확장성과 고가용성을 확보하여 더 많은 사용자를 수용하는 안정적인 시스템을 구축할 수 있습니다. 해당 가이드는 여러분의 애플리케이션의 확장성과 고가용성 달성을 목표로 DB Replication에 대해 설명합니다. 복제의 개념, 복제 유형, 설정 절차, 유지 관리 및 보안 고려 사항을 포괄적으로 설명합니다.

----------

## 1. 데이터베이스 복제 이론

### 1.1 복제란 무엇인가?

데이터베이스 복제(Database Replication)는 하나의 데이터베이스에서 발생한 변경 사항을 다른 데이터베이스에 복사하여 여러 데이터베이스 인스턴스가 동일한 데이터를 보유하도록 하는 기술입니다. 이를 통해 시스템은 데이터의 일관성을 유지하면서도 성능 향상과 고가용성을 달성할 수 있습니다. 복제는 주로 읽기 부하 분산, 장애 복구, 데이터 백업 등의 목적으로 활용됩니다.

복제는 소스-레플리카 구조나 멀티 소스 구조 등 다양한 방식으로 구현될 수 있으며, 데이터 전송 방법에 따라 동기식과 비동기식 복제로 구분됩니다. 이러한 복제 기술을 적절히 활용하면 대용량 트래픽을 효율적으로 처리하고, 시스템 장애 시에도 서비스 연속성을 보장할 수 있습니다. 자세한 내용은 다음 섹션에서 더욱 심도 있게 다루겠습니다.

> **DB Replication으로 얻을 수 있는 확장성과 고가용성**
> 1. 스케일 아웃 (Scale-out)
> 애플리케이션으로부터 실행되는 쿼리들을 분산 처리, 갑자기 늘어나는 트래픽을 유연하게 대응할 수 있다.
> 2. 데이터 백업
> DB 서버는 저장된 데이터를 주기적으로 백업하는 것이 필수적이다. 하지만 동일한 서버 내에서 백업이 실행되는 경우 백업 프로그램과 DBMS가 서버의 자원을 공유해서 사용한다. DB Replication은 백업 작업등을 Replica 서버로 분리함으로써 고가용성을 지킬 수 있다.
> 3. 데이터 분석
> 차세대 비즈니스 모델을 발굴하기 위한 분석용 쿼리들은 대량의 데이터를 조회하는 경우가 많다. 그런데 집계 연산 쿼리들은 굉장히 복잡하고 무거운 경우가 대부분이다. 이로 인해 서비스에서 직접적으로 사용되는 다른 쿼리들이 영향을 받는 경우는 치명적이다. DB Replication은 분석용 쿼리를 전용으로 실행할 수 있는 독립적인 환경을 제공해줄 수 있다.
> 4. 데이터의 지리적 분산
> 서비스에서 사용되는 애플리케이션 서버와 DB 서버는 지리적으로 근적한 위치에 존재할 수도 있고 떨어져 있을 수도 있다. 서비스의 응답 속도는 애플리케이션 서버의 처리 속도와 더불어 이러한 서버 간의 통신 거리만큼 비례해서 늘어난다. DB서버의 위치를 이동시키지 못한다면 복제를 사용해 애플리케이션 서버가 위치한 곳에 기존 DB에 대한 레플리카 서버를 새로 구축해 사용할 수 있다.

### 1.2 DB Replication 기본 도식

![](https://velog.velcdn.com/images/libienz/post/6376c53c-33aa-439d-8f55-a806f6b76d1c/image.png)

-   **소스 서버(Source Server)**: 데이터를 원본으로 저장하는 주 서버
-   **레플리카 서버(Replica Server)**: 소스 서버에서 발생한 변경 사항을 지속적으로 복사하여 유지하는 보조 서버

소스 서버는 모든 쓰기 작업(INSERT, UPDATE, DELETE 등)을 처리하며, 발생한 데이터 변경 사항을 복제 로그에 기록하여 복제본 서버로 전송합니다. 복제본 서버는 이 복제 로그를 기반으로 소스 서버의 변경 사항을 적용하여 동일한 데이터 상태를 유지하고, 클라이언트의 읽기 요청을 처리하여 소스 서버의 부하를 줄입니다. 

결과적으로 DB Replication을 적용한 시스템 구조는 여러 대의 복제본 서버를 둘 수 있어 읽기 부하를 효율적으로 분산할 수 있으며, 소스 서버에 장애가 발생하면 복제본 서버 중 하나를 승격(failover)하여 서비스 연속성을 유지할 수 있습니다.

> 이전에는 데이터베이스 복제에서 Master와 Slave라는 용어가 일반적으로 사용되었습니다. 그러나 이러한 용어는 인종적이고 역사적으로 민감한 의미를 내포하고 있어, 포용성과 다양성을 중시하는 현대 사회에서 부적절하다는 지적이 제기되었습니다.
> 
> 이에 따라 많은 기술 커뮤니티와 기업들이 더 중립적이고 명확한 용어로 변경하기로 결정했습니다. Master는 Source 또는 Primary로, Slave는 Replica, Secondary, 또는 Standby 등으로 대체되었습니다. 해당 가이드에서는 Source - Replica로 용어를 통일함을 말씀드립니다. 



### 1.3 복제 아키텍처
복제의 전반적인 과정을 깊게 이해할 수 있도록 복제 아키텍쳐를 살펴봅시다. MYSQL에서 발생하는 모든 변경 사항은 바이너리 로그 파일에 기록되는데, MYSQL에서의 복제는 이를 이용하는 방식을 취합니다. 변경을 기록하고 변경을 기록한 바이너리 로그가 전파되는 것으로 복제의 과정을 요약할 수 있겠습니다.

다음 그림은 MYSQL에서 복제 동기화가 처리되는 전반적인 과정을 보여줍니다.
![](https://velog.velcdn.com/images/libienz/post/5d4e8d50-395a-4c43-bae6-663582ad291b/image.png)


1. 소스 서버에서 이벤트 발생, **트랜잭션 처리 스레드**에 의해 DB 상태 변경이 바이너리 로그에 기록된다.
2. 레플리카 서버의 **레플리케이션 I/O 스레드**는 소스 서버의 바이너리 로그 덤프 스레드에게 바이너리 로그 정보를 요청한다. 
3. 요청을 받은 **바이너리 로그 덤프 스레드**는 바이너리 로그에서 이벤트를 읽어온 후 전송한다. 
3. **레플리케이션 I/O 스레드**는 바이너리 로그 덤프 스레드로부터 받아온 바이너리 로그 정보를 기반으로 릴레이 로그를 생성한다.
4. **레플리케이션 SQL 스레드**는 릴레이 로그에 기록된 이벤트를 읽고 SQL을 실행한다.

레플리카 서버에서 레플리케이션 I/O 스레드와 SQL 스레드는 서로 독립적으로 동잡합니다. 그러므로 만약 SQL 스레드에서 이벤트를 적용하는 것이 느리더라도 I/O 스레드는 이에 영향을 받지 않은 채 하나의 제어 흐름을 유지할 수 있습니다. 또 그림에서 확인할 수 있듯이 레플리카 서버에서 소스 서버의 변경 사항들이 적용되는 것은 소스 서버가 동작하는 것과는 별개로 진행됩니다. 레플리카 서버에 문제가 생기더라도 소스 서버가 영향을 받지 않을 수 있도록 설계한 결과라고 볼 수 있습니다.

### 1.4 DB Replication에서 고려해야할 여러 부분들
이 글을 읽고 계시는 분들은 DB Replication을 적용하기 위해 위처럼 이미 잘 구성된 위와 같은 아키텍쳐를 사용하기만 하면 된다고 생각할지도 모르겠습니다. 

하지만 우리는 복제에 대해 더욱 깊은 이해를 할 필요가 있습니다. 데이터베이스 복제는 일관성과 지연, 그리고 신속한 장애 복구가 고려되어야 하며 이를 위해 복제 아키텍처, 복제 타입, 복제 데이터 포맷, 그리고 복제 동기화 방식과 같은 핵심 요소들을 신중하게 고려되어야 하는 것입니다.

이어지는 글에서는 DB Replication에서 고려되어야 할 여러 가지 요소를 소개하고 설명합니다.

### 1.5 복제 타입
MYSQL의 복제는 소스 서버의 바이너리 로그에 기록된 이벤트들을 식별하는 방식에 따라 **바이너리 로그 파일 위치 기반 복제**(Binary Log File Position Based Replication)와 **글로벌 트랜잭션 ID 기반 복제**(Global Transaction Identifiers Based Replication)로 나뉩니다. 두 복제 방식의 개념, 동작 원리, 특징 및 장단점을 자세히 설명하겠습니다.

### 1.5.1 바이너리 로그 파일 위치 기반 복제

**바이너리 로그 파일 위치 기반 복제**는 소스 서버의 바이너리 로그 파일 이름과 해당 파일 내의 위치(offset)를 기반으로 복제를 수행하는 방식입니다. 레플리카 서버는 소스 서버의 특정 바이너리 로그 파일과 위치를 지정하여 그 지점부터 변경 사항을 복제합니다.

> ** 바이너리 로그 파일 위치 기반 복제 순서**
> 1. **바이너리 로그 생성**: 소스 서버에서 데이터 변경 작업(INSERT, UPDATE, DELETE 등)이 발생하면 해당 내용이 **바이너리 로그(Binary Log)**에 기록됩니다.
>
> 2. **파일 및 위치 정보**: 바이너리 로그는 순차적인 파일로 관리되며, 각 이벤트는 파일 내의 특정 위치(offset)에 저장됩니다.
> 
> 3. **레플리카 설정**: 레플리카 서버는 복제를 시작할 바이너리 로그 파일의 이름(`master_log_file`)과 위치(`master_log_pos`)를 설정합니다.
> 
> 4. **복제 수행**: 레플리카 서버는 지정된 파일과 위치부터 바이너리 로그를 읽어와 자신의 데이터베이스에 적용합니다.


바이너리 로그 파일 위치 기반 복제는 초기 설정이 비교적 간단하며 오랫동안 사용되어 온 전통적인 복제 방식입니다. 하지만 레플리카 서버가 소스 서버의 특정 위치를 추적해야 하므로, 복제 상태 관리가 복잡해질 수 있다는 단점을 가집니다. 또한 정확한 위치 정보를 기반으로 이루어지는 레플리케이션임으로 장애 복구의 어려움을 가진다는 점도 바이너리 로그 파일 위치 기반 복제의 또 다른 특징입니다.
> **장점**
> - 기존 시스템과의 호환성이 높고, 설정이 비교적 간단합니다.
> - 별도의 고유 식별자 관리가 필요하지 않습니다.
>
> **단점**
> - 복제 위치 추적이 어렵고, 관리 복잡성이 높습니다.
> - 장애 복구 시 정확한 위치 파악이 어려워 데이터 일관성 문제가 발생할 수 있습니다.
> - 중간에 바이너리 로그가 손상되거나 누락되면 복제가 중단될 수 있습니다.

### 1.5.2 글로벌 트랜잭션 ID 기반 복제


**글로벌 트랜잭션 ID 기반 복제**(Global Transaction ID, GTID-Based Replication)는 각 트랜잭션에 고유한 식별자인 **GTID**를 부여하여 복제를 수행하는 방식입니다. GTID는 소스 서버와 레플리카 서버 모두에서 트랜잭션을 고유하게 식별할 수 있게 해주며, 복제 상태 관리와 장애 복구를 용이하게 합니다.

> **글로벌 트랜잭션 ID 기반 복제 동작 순서**
> 1. **GTID 생성**: 소스 서버에서 트랜잭션이 커밋될 때마다 고유한 GTID가 생성되어 바이너리 로그에 기록됩니다. GTID는 일반적으로 `서버_UUID:트랜잭션번호` 형태로 표현됩니다.
>
> 2. **GTID 전파**: 레플리카 서버는 소스 서버의 바이너리 로그를 읽어오면서 GTID와 함께 트랜잭션을 수신합니다.
> 
> 3. **트랜잭션 적용 여부 판단**: 레플리카 서버는 수신한 GTID를 기반으로 해당 트랜잭션이 이미 적용되었는지 확인합니다. 이미 적용된 트랜잭션은 건너뛰고, 그렇지 않은 경우에만 적용합니다.
>
> 4. **복제 수행**: 적용되지 않은 트랜잭션을 레플리카 서버의 데이터베이스에 순차적으로 적용합니다.


글로벌 트랜잭션 ID 기반 복제에서 레플리카 서버는 GTID를 통해 복제 진행 상황을 자동으로 관리하므로, 복제 위치를 수동으로 지정할 필요가 없습니다. GTID 기반으로 복제 위치를 자동으로 파악할 수 있다는 것은 장애 복구의 용이성으로 이어지며 데이터의 일관성을 향상시킵니다. 바이너리 로그 위치 기반 복제 타입이 물리적으로 파일에 매핑된다면 GTID는 논리적인 데이터 타입으로 이해할 수 있습니다.


> **장점**
> - 복제 관리가 간편하며, 장애 복구 시 복잡도가 낮습니다.
> - 데이터 일관성과 무결성이 향상됩니다.
> - 복제 설정과 모니터링이 용이합니다.
> 
> **단점**
> - 초기 설정이 복잡하며, 기존 위치 기반 복제에서 전환 시 고려할 사항이 많습니다.
> - 약간의 성능 오버헤드와 추가 저장 공간이 필요합니다.
> - 일부 기능과의 호환성 문제가 있을 수 있습니다.

### 1.5.3 두 복제 방식의 비교

지금까지 설명드린 두 복제 방식을 정리하면 다음의 표로 나타낼 수 있습니다.

| 구분                  | 바이너리 로그 파일 위치 기반 복제 | 글로벌 트랜잭션 ID 기반 복제 |
|-----------------------|---------------------------|-------------------------|
| **설정 복잡도**          | 낮음                          | 높음                      |
| **장애 복구 용이성**      | 어려움                         | 쉬움                      |
| **데이터 일관성**        | 보통                          | 높음                      |
| **관리 편의성**         | 낮음                          | 높음                      |
| **기존 시스템 호환성**    | 높음                          | 낮음 (전환 필요)           |
| **성능 오버헤드**        | 낮음                          | 약간의 오버헤드 발생         |

바이너리 로그 파일 위치 기반 복제와 글로벌 트랜잭션 ID 기반 복제는 각각 장단점이 있으며, 시스템의 요구 사항과 규모에 따라 적합한 방식을 선택해야 합니다. GTID 기반 복제는 관리 편의성과 데이터 일관성 면에서 우수하지만, 초기 설정과 기존 시스템 전환에 대한 부담이 있을 수 있습니다. 반면에 위치 기반 복제는 설정이 간단하지만, 대규모 시스템에서의 관리와 장애 복구에 어려움이 있을 수 있습니다.

따라서 복제 방식을 선택할 때는 다음과 같은 요소를 종합적으로 고려해야 합니다.

- 시스템의 **규모**와 **복잡성**
- 데이터의 **중요성**과 **일관성 요구 수준**
- **장애 복구 시간**에 대한 요구 사항
- **기존 시스템과의 호환성** 및 **전환 비용**
- **관리자의 역량**과 **운영 팀의 숙련도**


적절한 복제 방식을 선택하고 올바르게 구성한다면, 데이터베이스의 확장성과 고가용성을 효과적으로 달성할 수 있을 것입니다.


> #### 바이너리 로그 파일 위치 기반 복제 추천 시나리오
> - **기존 시스템과의 호환성**이 중요한 경우
> - **단순한 복제 환경**을 구성하려는 경우
> - **초기 설정과 관리의 복잡성을 최소화**하고자 할 때
>
> #### 글로벌 트랜잭션 ID 기반 복제 추천 시나리오
> - **고가용성**과 **데이터 일관성**이 중요한 대규모 시스템
> - **장애 복구 시간 단축**과 **관리 효율성**이 필요한 경우
> - **자동화된 복제 관리**와 **모니터링**이 필요한 환경



### 1.6 복제 데이터 포맷

MySQL과 같은 데이터베이스 시스템에서는 복제 시 데이터 변경 사항을 어떤 포맷으로 전송할지 선택하는 것이 중요합니다. 이 복제 데이터 포맷은 **Statement 방식**, **Row 방식**, 그리고 **Mixed 방식**으로 나눌 수 있습니다. 각 방식은 데이터 변경 사항을 처리하는 방법과 특징이 다르며, 시스템의 요구 사항에 따라 적합한 방식을 선택해야 합니다. 이번 섹션에서는 이 세 가지 복제 방식에 대해 자세히 설명하겠습니다.

### 1.6.1 Statement-Based Replication (SBR)

**Statement 방식**은 데이터베이스에서 실행된 **SQL 문장 자체**를 복제본 서버에 전송하는 방식입니다. 즉, 소스 서버에서 실행된 DML(Data Manipulation Language) 문장(예: INSERT, UPDATE, DELETE)을 그대로 복제본 서버로 전달하여 동일한 문장을 실행하게 합니다.

> **SBR 동작 순서**
> 1. **SQL 문장 실행**: 소스 서버에서 클라이언트가 SQL 문장을 실행하면, 해당 문장이 데이터베이스에서 처리되어 데이터 변경이 발생합니다.
> 
> 2. **바이너리 로그 기록**: 소스 서버는 실행된 SQL 문장을 바이너리 로그(Binary Log)에 기록합니다.
> 
> 3. **로그 전송**: 레플리카 서버는 소스 서버의 바이너리 로그를 읽어와 중계 로그(Relay Log)에 저장합니다.
> 
> 4. **SQL 문장 재실행**: 레플리카 서버는 중계 로그에 저장된 SQL 문장을 자신의 데이터베이스에서 재실행하여 동일한 데이터 변경을 적용합니다.

Statement-Based Replication은 SQL 문장 자체를 전송하므로, 변경된 데이터 양이 많더라도 로그 크기가 비교적 작습니다. 그리고 레플리카 서버는 단순히 SQL 문장을 재실행하기 때문에 테이블 구조나 데이터 상태에 대한 사전 지식이 필요하지 않습니다. 이와 같은 장점들을 지니지만 단점도 있습니다. `NOW()`, `RAND()`와 같은 비결정적 함수를 사용하면 소스 서버와 레플리카 서버에서 다른 결과가 나올 수 있어 데이터 일관성이 깨질 수 있, 트리거나 스토어드 프로시저 내에서 복잡한 로직이 있을 경우 예상치 못한 부작용이 발생할 수 있습니다. 또한 대량의 데이터를 처리하는 복잡한 SQL 문장을 레플리카 서버에서 재실행하면 잠재적인 성능 저하 문제가 발생할 수도 있습니다.
발생할 수 있습니다.

## 1.6.2 Row-Based Replication (RBR)

**Row 방식**은 데이터 변경이 발생한 **행(row)의 데이터 자체**를 복제본 서버에 전송하는 방식입니다. 즉, 소스 서버에서 변경된 각 행의 데이터를 바이너리 로그에 기록하고, 이를 레플리카 서버로 전송하여 동일한 데이터를 적용합니다.

> **RBR 동작 순서**
> 1. **데이터 변경 발생**: 소스 서버에서 데이터 변경이 발생하면, 변경된 행의 새로운 값과 이전 값을 메모리에 저장합니다.
> 
> 2. **바이너리 로그 기록**: 변경된 행의 데이터 자체를 바이너리 로그에 기록합니다.
> 
> 3. **로그 전송**: 레플리카 서버는 소스 서버의 바이너리 로그를 읽어와 중계 로그에 저장합니다.
> 
> 4. **데이터 적용**: 레플리카 서버는 중계 로그에 저장된 행 데이터를 직접 자신의 데이터베이스에 적용합니다.

Row-Based Replication 포맷을 사용하면 소스 서버에서 변경된 데이터 자체를 전송하므로, 비결정적 함수나 트리거로 인한 데이터 불일치 문제가 발생하지 않습니다. 레플리카 서버가 SQL 문장을 재실행하지 않고 데이터만 적용함으로 실행 오버헤드가 줄어드는 것도 특징 중 하나입니다.

하지만 변경된 데이터의 양이 많을 경우 바이너리 로그의 크기가 매우 커질 수 있으며 테이블 구조의 동기화를 강제한다는 점은 Row-Based Replication의 단점입니다. 그리고 로그에 SQL 문장이 아닌 데이터 자체가 기록되므로, 로그를 통해 어떤 작업이 수행되었는지 파악하기 어려운 것도 단점 중 하나입니다.


### 1.6.3. Mixed-Based Replication (MBR)

**Mixed 방식**은 **Statement 방식**과 **Row 방식**을 상황에 따라 혼합하여 사용하는 방식입니다. 기본적으로는 Statement 방식을 사용하되, 특정 상황에서는 자동으로 Row 방식으로 전환합니다.

> ** MBR 동작 순서**
> 
> 1. **SQL 문장 실행**: 소스 서버에서 SQL 문장이 실행됩니다.
> 
> 2. **방식 결정**: MySQL 엔진이 해당 SQL 문장이 복제에 안전한지 판단하여, Statement 방식 또는 Row 방식 중 하나를 선택합니다.
>    - **복제에 안전한 경우**: Statement 방식 사용.
> 
>    - **복제에 안전하지 않은 경우**: Row 방식 사용.
> 
> 3. **바이너리 로그 기록**: 선택된 방식에 따라 바이너리 로그에 SQL 문장 또는 행 데이터를 기록합니다.
> 
> 4. **로그 전송 및 적용**: 레플리카 서버는 바이너리 로그를 읽어와 적절한 방식으로 데이터를 적용합니다.

Mixed-Based Replication는 상황에 따라 최적의 복제 방식을 자동으로 선택하여 적용합니다. 필요 시 Row 방식을 사용하여 데이터 일관성을 보장하면서도 불필요한 경우에는 Statement 방식으로 로그 크기를 줄이기에 상황에 따른 유연한 대처가 장점입니다. 하지만 복제 방식의 예측 가능성이 낮아 시스템 동작을 예측하기 어렵고 사용된 복제 포맷의 추적이 어려워 문제 발생 시 원인 파악이 어려울 수 있다는 단점이 존재합니다. 

### 1.6.4. 세 가지 방식의 비교

| 구분                    | Statement 방식            | Row 방식                 | Mixed 방식               |
|-------------------------|---------------------------|--------------------------|--------------------------|
| **바이너리 로그 내용**    | SQL 문장                   | 변경된 행의 데이터         | 상황에 따라 SQL 또는 행 데이터 |
| **로그 크기**            | 작음                       | 큼                        | 중간 정도                |
| **데이터 일관성**        | 낮음 (비결정적 함수 문제)   | 높음                      | 높음                     |
| **복잡한 SQL 처리**      | 레플리카 서버에서 재실행 필요 | 없음                      | 상황에 따라 다름          |
| **구현 및 관리 용이성**   | 비교적 쉬움                 | 테이블 구조 동기화 필요      | 복잡함                   |

Statement 방식, Row 방식, 그리고 Mixed 방식은 각기 다른 장단점을 지니며, 시스템의 특성과 요구 사항에 따라 적합한 방식을 선택해야 합니다. 데이터 일관성이 중요하다면 Row 방식을, 성능과 로그 크기가 중요하다면 Statement 방식을 고려할 수 있습니다. Mixed 방식은 두 방식의 장점을 취하면서도 단점을 보완하고자 하지만, 관리의 복잡성이 증가할 수 있습니다.

복제 방식의 선택은 데이터베이스 시스템의 안정성과 성능에 큰 영향을 미치므로, 충분한 검토와 테스트를 통해 최적의 방식을 선택하는 것이 중요합니다. 또한, 복제 설정 후에도 지속적인 모니터링과 관리가 필요하며, 상황에 따라 복제 방식을 조정하는 유연성이 필요합니다.

---

이상으로 복제 데이터 포맷의 세 가지 방식에 대해 살펴보았습니다. 각 방식의 특징과 차이점을 이해함으로써, 시스템에 가장 적합한 복제 방식을 선택하시기 바랍니다.

> **Statement 방식 추천 시나리오**
> 
> - **데이터 변경량이 적고**, **로그 크기를 최소화**하고자 할 때
> 
> - **비결정적 함수나 트리거를 사용하지 않는** 단순한 애플리케이션
> 
> - **성능 최적화**가 중요한 경우
> 
> **Row 방식 추천 시나리오**
> 
> - **데이터 일관성**이 가장 중요하며, **비결정적 함수나 트리거**를 많이 사용하는 경우
> 
> - **대용량 데이터 변경**이 빈번하지 않은 시스템
> 
> - **데이터 적용의 정확성**이 요구되는 금융, 의료 분야 등
> 
> **Mixed 방식 추천 시나리오**
> 
> - **유연한 복제 방식**이 필요한 경우
> 
> - **다양한 종류의 SQL 문장**이 실행되며, **복제 안전성**과 **로그 크기** 사이에서 균형을 찾고자 할 때
> 
> - **관리 복잡성**을 감수하더라도 **최적의 성능과 일관성**을 동시에 추구하는 경우

### 1.7 비동기 복제와 반동기 복제의 이해

데이터베이스 시스템에서 **복제 동기화**는 데이터의 일관성과 가용성을 유지하기 위한 중요한 요소입니다. 복제 동기화 방식은 시스템의 성능과 안정성에 직접적인 영향을 미치며, 주로 **비동기 복제**와 **반동기 복제** 두 가지 방식으로 나뉩니다. 이 글에서는 이 두 가지 복제 방식의 특징과 장단점을 자세히 살펴보겠습니다.

### 1.7.1 비동기 복제 (Asynchronous Replication)

<img width="1686" alt="image" src="https://github.com/user-attachments/assets/bd858dbf-637f-44d9-93c7-e65c15f177e5">

비동기 복제는 주 서버(Source Server)가 트랜잭션을 커밋하면 즉시 클라이언트에게 응답을 반환합니다. 복제본 서버(Replica Server)로의 데이터 전송은 그 이후에 비동기적으로 이루어집니다. 그리고 비동기 복제는 복제 지연 사능성이 있습니다. 주 서버와 복제본 서버 간의 데이터 동기화에 시간이 걸릴 수 있어, 복제본 서버의 데이터가 주 서버보다 최신 상태가 아닐 수 있는 것입니다. 비동기 복제 방식에서 주 서버는 복제본 서버의 상태와 관계없이 트랜잭션을 처리하므로 성능 저하가 작습니다.

> **장점**
> 1. **높은 성능**: 복제본 서버로의 데이터 전송을 기다리지 않고 트랜잭션을 처리하므로, 주 서버의 응답 속도가 빠릅니다.
> 2. **확장성**: 복제본 서버의 수를 늘려도 주 서버의 성능에 큰 영향을 주지 않아 시스템 확장이 용이합니다.
> 3. **단순한 구현**: 설정과 관리가 비교적 간단하여 운영 부담이 적습니다.
> 
> **단점**
> 1. **데이터 일관성 문제**: 복제 지연으로 인해 복제본 서버의 데이터가 주 서버와 일치하지 않을 수 있습니다. 이는 읽기 작업에서 일관성 있는 데이터를 요구하는 애플리케이션에 문제가 될 수 있습니다.
> 2. **데이터 손실 위험**: 주 서버에 장애가 발생하면, 아직 복제되지 않은 트랜잭션은 복제본 서버에 반영되지 않아 데이터 손실이 발생할 수 있습니다.
> 3. **장애 복구 복잡성**: 데이터 불일치로 인해 장애 복구 시 추가적인 작업이 필요할 수 있습니다.

### 1.7.2 반동기 복제 (Semi-Synchronous Replication)
<img width="1685" alt="image" src="https://github.com/user-attachments/assets/ac97ba5c-da40-4226-b310-541a65dd11d9">

반동기 복제는 주 서버가 트랜잭션을 커밋할 때, 최소한 하나의 복제본 서버가 해당 트랜잭션을 수신했음을 확인해야 커밋이 완료됩니다. 복제본 서버에 데이터가 안전하게 저장되었음을 보장하므로, 데이터 손실 위험이 감소합니다. 하지만 복제본 서버의 확인을 기다려야 하므로 주 서버의 트랜잭션 응답 시간이 늘어날 수 있습니다.

> **장점**
> 1. **데이터 안정성 향상**: 최소 하나의 복제본 서버에 데이터가 안전하게 저장되므로, 주 서버 장애 시 데이터 손실 위험이 감소합니다.
> 2. **데이터 일관성 개선**: 복제 지연이 줄어들어 복제본 서버의 데이터가 주 서버와 더 일치하게 됩니다.
> 3. **장애 복구 용이성**: 복제본 서버의 데이터가 주 서버와 거의 동일하므로 장애 발생 시 복구가 수월합니다.
> **단점**
> 1. **성능 저하**: 복제본 서버의 응답을 기다려야 하므로 주 서버의 트랜잭션 처리 속도가 느려질 수 있습니다.
> 2. **복잡한 설정**: 비동기 복제보다 설정과 관리가 복잡하며, 복제본 서버의 안정성이 중요합니다.
> 3. **확장성 제한**: 복제본 서버의 상태에 따라 주 서버의 성능이 영향을 받을 수 있어, 대규모 시스템에서는 제한이 있을 수 있습니다.

### 1.7.3 두 복제 방식의 비교

| 구분             | 비동기 복제                              | 반동기 복제                             |
|------------------|-----------------------------------------|-----------------------------------------|
| **데이터 일관성**   | 낮음 (복제 지연 발생 가능)                  | 높음 (최소 한 곳에 데이터 저장 보장)         |
| **성능**          | 높음 (주 서버의 응답 속도 빠름)             | 낮음 (복제본 서버의 응답 대기)              |
| **데이터 손실 위험**| 높음 (주 서버 장애 시 데이터 손실 가능)       | 낮음 (복제본 서버에 데이터 저장 확인)       |
| **설정 복잡도**    | 낮음 (간단한 구현)                        | 높음 (추가 설정 및 관리 필요)              |
| **확장성**        | 높음 (복제본 서버 추가 시 영향 적음)         | 낮음 (복제본 서버 상태에 따라 주 서버 영향)  |
| **장애 복구 용이성**| 낮음 (데이터 불일치 가능성)                 | 높음 (데이터 일관성으로 복구 용이)          |

**최적의 복제 방식을 선택하기 위해서는 시스템의 요구 사항과 우선순위를 명확히 파악해야 합니다.** 성능과 확장성이 중요하다면 비동기 복제를, 데이터 일관성과 안정성이 더 중요하다면 반동기 복제를 선택하는 것이 일반적입니다. 또한, 현대의 복잡한 시스템에서는 두 방식을 혼합하거나 다른 복제 전략을 적용하여 장단점을 보완하기도 합니다.


> **비동기 복제는 추천 시나리오**
> - **높은 성능과 확장성**이 필요한 시스템에 적합합니다.
> - **데이터 일관성보다 응답 속도**가 중요한 애플리케이션에서 유용합니다.
> - 데이터 손실 위험을 감수할 수 있는 환경에서 사용됩니다.
> 
> ### 반동기 복제는...
> - **데이터 일관성과 안정성**이 중요한 시스템에 적합합니다.
> - **데이터 손실을 최소화**해야 하는 애플리케이션에서 유용합니다.
> - 약간의 성능 저하를 받아들일 수 있는 환경에서 사용됩니다.



> **참고:** 복제 방식 선택 시에는 네트워크 상태, 복제본 서버의 성능, 트랜잭션 처리량 등 다양한 요소를 고려해야 합니다. 또한, 데이터베이스 시스템에서 제공하는 기능과 설정 옵션을 충분히 이해하고 활용하는 것이 중요합니다.


### 1.8 복제 토폴로지: 다양한 복제 구성 방식의 이해

데이터베이스 시스템에서 **복제 토폴로지(Replication Topology)**는 데이터 복제를 어떻게 구성하고 관리할지에 대한 구조를 말합니다. 적절한 복제 토폴로지를 선택하면 시스템의 성능, 확장성, 고가용성을 크게 향상시킬 수 있습니다. 이번 글에서는 **싱글 레플리카 복제 구성**, **멀티 레플리카 복제 구성**, **체인 복제 구성**, **듀얼 소스 복제 구성**, **멀티 소스 복제 구성**에 대해 자세히 살펴보겠습니다.

### 1.8.1 싱글 레플리카 복제 구성 (Single Replica Replication Configuration)

**싱글 레플리카 복제 구성**은 하나의 소스 서버(Source Server)와 하나의 복제본 서버(Replica Server)로 구성된 가장 기본적인 복제 형태입니다. 소스 서버에서 발생한 데이터 변경 사항은 단일 복제본 서버로 복제됩니다.

- **간단한 설정**: 구성과 관리가 쉬워 복제 시스템을 처음 도입할 때 적합합니다.
- **읽기 부하 분산**: 복제본 서버를 통해 읽기 작업을 처리하여 소스 서버의 부하를 줄일 수 있습니다.
- **고가용성 향상**: 소스 서버에 장애가 발생하면 복제본 서버로 신속하게 전환할 수 있습니다.



> **장점**
> - 설정과 관리가 용이합니다.
> - 최소한의 자원으로 복제 환경을 구축할 수 있습니다.

> **단점**
> - 복제본 서버가 하나뿐이므로 복제본 서버에 장애가 발생하면 읽기 부하 분산 효과가 사라집니다.
> - 확장성에 한계가 있습니다.

### 1.8.2. 멀티 레플리카 복제 구성 (Multi-Replica Replication Configuration)


**멀티 레플리카 복제 구성**은 하나의 소스 서버와 여러 개의 복제본 서버로 구성됩니다. 소스 서버에서 발생한 데이터 변경 사항은 모든 복제본 서버로 복제됩니다.

- **확장성 향상**: 복제본 서버의 수를 늘려 읽기 성능을 수평적으로 확장할 수 있습니다.
- **부하 분산**: 다수의 복제본 서버를 통해 대량의 읽기 요청을 효과적으로 처리합니다.
- **고가용성 강화**: 복제본 서버 중 일부에 장애가 발생하더라도 다른 복제본 서버로 서비스가 지속됩니다.


> **장점**
> - 읽기 성능과 시스템의 확장성이 크게 향상됩니다.
> - 고가용성을 높일 수 있습니다.
> **단점**
> - 복제본 서버의 증가로 관리 복잡성이 높아집니다.
> - 네트워크 트래픽과 자원 소비가 증가할 수 있습니다.

### 1.8.3. 체인 복제 구성 (Chain Replication Configuration)


**체인 복제 구성**은 소스 서버와 복제본 서버들이 **연속적인 사슬(chain)** 형태로 연결된 복제 방식입니다. 소스 서버의 변경 사항은 첫 번째 복제본 서버로 전달되고, 그 이후 각 복제본 서버는 다음 서버로 데이터를 전달합니다.


- **복제 부하 분산**: 소스 서버가 모든 복제본 서버에 직접 데이터를 전송하지 않고, 각 서버가 다음 서버로 데이터를 전달하므로 소스 서버의 부하가 감소합니다.
- **복제 지연 증가**: 데이터가 여러 단계를 거쳐 전달되므로 최종 복제본 서버까지 데이터 적용에 지연이 발생할 수 있습니다.


> **장점**
> - 소스 서버의 복제 부담을 줄일 수 있습니다.
> - 대규모 복제 환경에서 효율적입니다.
> **단점**
> - 복제 지연으로 인해 데이터 일관성에 문제가 생길 수 있습니다.
> - 중간 복제본 서버에 장애가 발생하면 이후 서버로의 복제가 중단됩니다.

### 1.8.4. 듀얼 소스 복제 구성 (Dual Source Replication Configuration)

**듀얼 소스 복제 구성**은 두 개의 소스 서버가 서로에게 데이터를 복제하는 **양방향 복제** 구조입니다. 각 서버는 서로의 변경 사항을 받아들여 동일한 데이터 상태를 유지합니다.

- **고가용성 강화**: 한 서버에 장애가 발생하면 다른 서버가 서비스를 계속 제공할 수 있습니다.
- **쓰기 부하 분산**: 두 서버에서 모두 쓰기 작업이 가능하므로 쓰기 성능이 향상됩니다.


> **장점**
> - 고가용성과 쓰기 성능이 향상됩니다.
> - 데이터 일관성을 유지하면서 양쪽에서 작업이 가능합니다.
> **단점**
> - **데이터 충돌 위험**: 동일한 데이터에 대해 동시에 쓰기 작업이 발생하면 충돌이 생길 수 있습니다.
> - 충돌 해결을 위한 추가 메커니즘이 필요합니다.
> - 관리와 설정이 복잡합니다.

### 1.8.5. 멀티 소스 복제 구성 (Multi-Source Replication Configuration)


**멀티 소스 복제 구성**은 하나의 복제본 서버가 여러 개의 소스 서버로부터 데이터를 복제받는 구조입니다. 이를 통해 여러 데이터 소스를 하나의 서버에서 통합할 수 있습니다.

- **데이터 통합**: 분산된 여러 데이터베이스의 데이터를 한 곳에서 관리하고 조회할 수 있습니다.
- **효율적인 리소스 사용**: 복제본 서버 하나로 여러 소스 서버의 데이터를 처리하여 자원 사용을 최적화합니다.

> **장점**
> - 데이터 통합과 중앙 집중 관리가 가능합니다.
> - 시스템 자원의 효율성을 높일 수 있습니다.
> **단점**
> - 소스 서버 간 데이터 스키마나 데이터 충돌 관리가 어렵습니다.
> - 복제본 서버의 부하가 증가하여 성능 저하가 발생할 수 있습니다.

### 1.8.6. 각 복제 토폴로지의 선택 기준
복제 토폴로지는 시스템의 요구 사항과 규모에 따라 적절히 선택되어야 합니다. 각 구성 방식은 고유한 장단점이 있으며, 이를 이해하고 적용함으로써 데이터베이스 시스템의 성능과 안정성을 높일 수 있습니다. 복제 구성 시에는 데이터 일관성, 시스템 부하, 관리 복잡성 등을 종합적으로 고려해야 합니다.

**참고로**, 복제 토폴로지를 설계할 때는 다음 사항을 유의해야 합니다.

- **데이터 일관성 보장**: 복제 지연이나 데이터 충돌로 인한 일관성 문제를 방지하기 위한 메커니즘 필요
- **장애 대응 전략 수립**: 복제본 서버나 소스 서버의 장애 시 신속한 복구 방안 마련
- **관리 및 모니터링 체계 구축**: 복제 상태를 지속적으로 모니터링하고 문제 발생 시 대응할 수 있는 체계 필요

올바른 복제 토폴로지의 선택과 구현은 서비스의 안정성과 사용자 경험에 큰 영향을 미칩니다. 시스템의 특성과 목표에 맞는 복제 구성을 통해 효율적이고 신뢰성 있는 데이터베이스 환경을 구축하시기 바랍니다.
### 싱글 레플리카 복제 구성

- **소규모 시스템**에서 간단한 복제가 필요할 때
- **읽기 부하**가 많지 않은 경우

### 멀티 레플리카 복제 구성

- **읽기 부하가 많은 시스템**에서 확장성이 필요할 때
- **고가용성**이 중요한 서비스

### 체인 복제 구성

- **대규모 복제 환경**에서 소스 서버의 부하를 최소화하고자 할 때
- **복제본 서버 간의 네트워크 연결**이 안정적인 경우

### 듀얼 소스 복제 구성

- **고가용성과 쓰기 성능**을 동시에 추구할 때
- **데이터 충돌 관리**에 대한 명확한 전략이 있을 때

### 멀티 소스 복제 구성

- **여러 데이터 소스의 통합 관리**가 필요할 때
- **데이터 통합 분석**이 중요한 시스템

## 2 결론

오늘날 빠르게 변화하는 기술 환경에서 시스템의 확장성과 고가용성을 확보하는 것은 그 어느 때보다 중요해졌습니다. 데이터베이스 복제는 증가하는 부하와 장애 대응의 필요성에 대처할 수 있는 강력한 해결책으로 부상하고 있습니다. 적절한 복제 아키텍처, 복제 타입, 데이터 포맷, 동기화 방식을 신중하게 선택함으로써 애플리케이션의 특정 요구 사항에 맞는 복제 전략을 수립할 수 있습니다.

이 가이드에서는 데이터베이스 복제의 기본 개념부터 다양한 복제 유형과 토폴로지에 이르기까지 심도 있게 탐구했습니다. 복제는 단순히 기술적인 구현에 그치지 않고, 데이터 일관성, 시스템 성능, 관리 복잡성 등 여러 요소를 종합적으로 고려해야 하는 복합적인 과제입니다.

물론 데이터베이스 복제를 구현하는 과정에서 여러 도전 과제가 있을 수 있지만, 이를 통해 얻을 수 있는 확장성, 신뢰성, 성능 향상은 충분한 가치가 있습니다. 복제를 도입할 때는 시스템의 요구 사항을 면밀히 분석하고, 다양한 설정을 테스트하며, 지속적으로 모니터링하고 조정하는 노력이 필요합니다.

데이터베이스 복제의 힘을 활용하여 견고하고 탄력적인, 그리고 확장 가능한 시스템을 구축함으로써 현대 애플리케이션의 요구 사항을 충족시키고 사용자에게 일관되고 원활한 서비스를 제공하시기 바랍니다.
