---
author: "burningfalls"
generation: 6
level: "unclassified"
original_filename: "technical.md"
source: "https://github.com/woowacourse/woowa-writing/blob/burningfalls/technical.md"
source_path: "technical.md"
---

# Amazon S3를 활용한 이미지 파일 관리 방법 알아보기

## 0. 개요

웹 또는 앱 서비스를 개발하면서 "어떻게 하면 사용자들에게 빠르고 안정적인 이미지 파일을 제공할 수 있을까"라는 고민을 해본 적이 있다면, Amazon S3(Simple storage Service)가 그 해답이 될 수 있다. S3는 뛰어난 확장성과 보안성을 갖춘 클라우드 스토리지 서비스로, 프로젝트 규모와 상관없이 유연하게 적용할 수 있다. 특히, 이미지 파일은 사용자 경험(UX)에 큰 영향을 미치는 중요한 요소이다. 이 글에서는 S3와 CloudFront의 주요 기능과 장점을 중심으로, 이를 프로젝트에 적용하는 방법과 실제 개발 시 고민해볼 부분들을 소개한다. S3를 활용한 파일 관리의 가치를 경험하고 프로젝트를 한 단계 더 발전시켜보고 싶다면, 이 글이 유용한 가이드가 될 것이다.

## 1. 정적 파일 관리

### A. 정적 파일이란?

정적 파일은 서버가 별도의 처리 없이 바로 사용자에게 제공하는 파일을 의미하며, 이미지, 동영상, 음악, CSS, JavaScript 파일 등을 포함한다. 이러한 파일들은 한 번 서버에 저장된 후, 업데이트나 변경이 자주 발생하지 않기 때문에 '정적'이라는 용어로 불린다.

정적 파일은 브라우저의 요청에 따라 서버가 직접 전달하며, 보통 콘텐츠 전송 네트워크(CDN)나 클라우드 스토리지와 같은 외부 저장소를 이용하여 서버의 부하를 줄이는 방식으로 관리한다.

### B. 정적 파일의 역할과 중요성

정적 파일은 웹사이트 사용자 경험(UX)에 큰 영향을 준다. 예를 들어, 이미지와 동영상은 시각적 요소를 통해 분위기를 조성하고, CSS는 웹사이트의 디자인을, JavaScript는 다양한 상호작용을 가능하게 한다. 이러한 파일들의 로딩 속도가 빠를수록 사용자가 웹사이트를 더 쾌적하게 이용할 수 있다.

정적 파일은 일반적으로 자주 변경되지 않으므로, 캐싱 기술을 활용하여 성능을 최적화할 수 있다. 캐싱을 통해 한 번 다운로드된 파일을 브라우저 또는 CDN에 저장하여, 이후 요청 시 재다운로드 없이 캐시에서 직접 제공함으로써 서버 응답 시간을 단축하고, 네트워크 대역폭을 절약할 수 있다.

### C. 정적 파일 배포 방법의 변화

과거에는 웹 서버가 직접 정적 파일을 관리하고 제공했다. 그러나, 이미지나 동영상 같은 대용량 파일이 많아지면서 서버의 과부하 문제가 발생했다. 특히 트래픽이 많은 경우, 사용자들에게 느린 속도로 콘텐츠를 제공할 수밖에 없는 한계가 있었다.

현재는 Amazon S3와 같은 클라우드 스토리지 서비스를 이용해 정적 파일을 저장하고 관리하는 방식이 더 일반화되었다. S3는 파일을 안전하게 저장하고, 전 세계에 빠르게 배포할 수 있도록 지원한다. 이를 CloudFront와 같은 CDN과 결합하면, 사용자들이 어디에 있든지 간에 파일을 빠르게 다운로드할 수 있다. 예를 들어, 미국에 있는 사용자와 한국에 있는 사용자 모두 각자의 위치에서 가까운 서버로부터 동일한 파일을 빠르게 다운로드할 수 있다.


## 2. S3의 주요 특징과 장점

### A. Amazon S3 소개

Amazon S3는 AWS(Amazon Web Services)에서 제공하는 클라우드 기반의 객체 스토리지 서비스로, 데이터를 안정적으로 저장하고 관리하는 데 최적화된 솔루션이다. S3는 대용량 데이터 처리와 백업에 강점이 있으며, 개발자와 기업이 어디서나 안전하게 데이터에 접근할 수 있도록 지원한다.

S3는 데이터를 버킷에 저장하며, 각 버킷은 특정 리전에 속해 관리된다. 사용자는 필요한 데이터 저장 용량만큼만 요금을 지불하는 유연한 과금 방식을 통해 초기 비용을 최소화할 수 있다.

### B. S3의 주요 특징

Amazon S3는 확장성, 내구성, 가용성 등 여러 면에서 강력한 기능을 제공하여 대규모 데이터 관리에 적합하다.

* 확장성: S3는 데이터 양에 따라 자동으로 확장되며, 소규모 프로젝트에서 대규모 데이터 아키텍처까지 유연하게 활용할 수 있다.

* 내구성: S3는 데이터를 여러 물리적 위치에 복제하여 보관하므로, 데이터 손실 위험을 극도로 낮춘다. 따라서 사용자는 데이터를 안전하게 보관할 수 있다.

* 가용성: S3는 99.99%의 가용성을 제공하여 언제나 안정적으로 서비스에 접근할 수 있도록 보장한다. 이는 서비스 장애로 인한 데이터 접근 불가 상황을 최소화한다.

* 보안: S3는 업로드 시부터 데이터 암호화를 지원하며, 접근 제어 목록(ACL)과 버킷 정책을 통해 특정 사용자나 그룹에게만 접근 권한을 부여할 수 있다. 또한, AWS IAM(Identity and Access Management)과 통합하여 세밀한 권한 설정을 제공한다.

* 버전 관리 기능: S3는 파일의 변경 이력을 자동으로 관리하여, 삭제되거나 변경된 파일의 이전 버전을 언제든지 복구할 수 있게 해준다. 따라서 실수로 인한 데이터 손실을 방지할 수 있다.

### C. S3의 장점

Amazon S3는 다양한 장점 덕분에 클라우드 스토리지 솔루션으로 널리 사용된다.

* 비용 효율성: S3는 사용량 기반 과금 방식을 적용하여 초기 비용을 절감할 수 있으며, 자주 사용하지 않는 데이터는 저렴한 S3 Glacier를 통해 장기 보관할 수 있어 경제적이다.

* 글로벌 네트워크: 전 세계 AWS 리전을 통해 데이터를 안전하게 저장하고 빠르게 제공하며, CloudFront와 결합 시 전 세계 사용자에게 더욱 빠른 속도로 데이터를 전달할 수 있다.

* 안정성: S3는 여러 위치에 데이터를 복제해 두어, 특정 서버에 문제가 생기더라도 다른 위치에서 데이터를 복구할 수 있다. 이러한 복제 기술로 장애 발생 시에도 신속하게 데이터를 복구할 수 있다.

* AWS와의 통합성: S3는 AWS의 다양한 서비스와 긴밀하게 통합된다. 예를 들어, Lambda와 연동하여 S3에 파일이 업로드될 때 자동으로 처리 작업을 수행하거나, Athena를 통해 저장된 데이터를 즉시 분석할 수 있다.

* 데이터 복구 및 내구성: 데이터의 내구성을 보장하고 데이터 복구 기능을 제공하여 실수로 삭제하거나 수정된 데이터를 쉽게 복원할 수 있다.

* 유연한 접근 방식: 웹 인터페이스, CLI, SDK 등 다양한 방식으로 데이터를 관리할 수 있으며, Presigned URL 기능으로 특정 사용자에게 제한된 시간 동안 안전하게 파일을 제공할 수 있다.

## 3. 이미지 파일 저장 방법

### A. S3 버킷 생성 및 설정 방법

이미지를 S3에 저장하려면 먼저 S3 버킷(bucket)을 생성해야 한다. 버킷은 S3에서 데이터를 저장하는 기본 단위로, 여러 파일(객체)을 관리하는 용도로 사용된다. 버킷 생성 절차는 다음과 같다.

1. AWS 콘솔에 로그인한 후, S3 서비스로 이동한다.
2. Create bucket을 클릭한 후, 버킷 이름을 입력한다. 버킷 이름은 전 세계적으로 고유해야 하며, 소문자, 숫자, 하이픈(-)만 사용할 수 있다.
3. 리전(Region)을 선택한다. 버킷이 생성될 리전은 사용자의 위치나 서비스 특성에 따라 선택할 수 있으며, 가까운 리전을 선택하면 데이터 전송 속도가 더 빨라진다.
4. 권한 설정에서 기본적으로 활성화된 Block all public access는 보안을 위해 권장되는 설정이다. 이미지 파일을 공개적으로 제공하려면 이 설정을 해제하고 추가로 버킷 정책을 설정해야 한다.
5. 기타 버전 관리, 태그 추가 등 필요한 설정을 마친 후, Create bucket을 클릭하면 버킷이 생성된다.

버킷이 생성된 후 이미지 파일을 업로드할 수 있으며, 특정 사용자나 그룹에만 접근을 허용할 수도 있다.

### B. S3Client 사용 방법

S3Client는 AWS SDK로 제공되며, Spring Boot에서 파일 업로드와 다운로드를 쉽게 지원한다. S3Client를 설정하고 사용하는 방법은 다음과 같다.

1. 의존성 추가: 먼저, `build.gradle` 파일에 AWS SDK를 추가한다.

```gradle
implementation 'software.amazon.awssdk:s3'
```

2. S3Client 설정: Spring에서 S3Client를 빈(bean)으로 설정한다.

```java
import java.beans.BeanProperty;

@Configuration
public class s3Client() {

    @Bean
    public S3Client s3Client() {
        return S3Client.builder()
                .region(Region.US_EAST_1)
                .build();
    }
}
```

3. 이미지 파일 업로드: 파일을 S3에 업로드하는 코드를 작성한다.

```java
import java.io.IOException;

@Service
public class S3Service {
    private final S3Client s3Client;

    public S3Service(S3Client s3Client) {
        this.s3Client = s3Client;
    }

    public void uploadFile(MultipartFile file, String bucketName) {
        try {
            PutObjectRequest request = PutObjectRequest.builder()
                    .bucket(bucketName)
                    .key(file.getOriginalFilename())
                    .build();
            
            // S3 버킷으로 이미지 업로드
            s3Client.putObject(request, RequestBody.fromBytes(file.getBytes()));
        } catch (IOException e) {
            throw new RuntimeException("파일 업로드 중 오류가 발생했습니다.");
        }
    }
}
```

이렇게 설정하면 Spring 애플리케이션에서 S3 버킷으로 이미지를 손쉽게 업로드할 수 있다. 추가로, 파일 다운로드 및 삭제 등의 작업도 S3Client를 사용하여 구현할 수 있다.

### C. 객체 MIME Type 관리

S3에 이미지를 업로드할 때, MIME Type을 설정하는 것은 매우 중요하다. MIME Type은 파일이 어떤 형식인지 브라우저에게 알려주기 때문에, 이를 올바르게 설정해야 브라우저에서 이미지가 제대로 표시된다. MIME Type을 설정하는 방법은 아래와 같다.

1. 파일 업로드 시 MIME Type 설정: 파일을 업로드할 때 Content-Type을 지정하여 MIME Type을 설정할 수 있다.

```java
PutObjectRequest request = PutObjectRequest.builder()
        .bucket(bucketName)
        .key(fileName)
        .contentType("image/jpeg")  // MIME Type 설정
        .build();
```

2. Spring의 MediaType 클래스 사용: Spring에서는 MediaType 클래스를 활용하여 파일의 MIME Type을 쉽게 처리할 수 있으며, 파일 확장자에 따라 적절한 MIME Type이 자동으로 설정된다.

```java
String mimeType = URLConnection.guessContentTypeFromName(file.getOriginalFilename());
if (mimeType == null) {
    mimeType = "application/octet-stream";
}
```

정확한 MIME Type을 설정하면 브라우저에서 이미지 파일이 올바르게 렌더링되고, 클라이언트와 서버 간의 통신에서 파일 유형을 명확히 할 수 있어 효율적인 파일 관리가 가능하다.

여기서 `application/octet-stream` 타입은 파일의 MIME Type이 명확하지 않을 때 사용되는 기본 바이너리 데이터 타입이다. 이 타입은 특정한 파일 형식을 나타내지 않지만, 파일이 이진 데이터임을 브라우저나 클라이언트에게 알려준다. 따라서, 클라이언트는 이 타입의 파일을 다운로드하거나 저장할 수 있는 데이터로 인식하게 된다.

`mimeType`이 `null`일 때 `application/octet-stream`을 설정하는 이유는 파일의 정확한 MIME Type을 감지할 수 없는 경우에도 안전하게 데이터를 전송할 수 있도록 보장하기 위해서이다. MIME Type이 `null`이면 브라우저나 클라이언트는 파일을 올바르게 해석하지 못할 수 있다. 따라서 기본적으로 `application/octet-stream`을 설정하면, 클라이언트가 파일을 다운로드할 수 있는 형식으로 처리하여 오류를 방지하고, 파일 손상이나 잘못된 표시를 예방할 수 있다.

이러한 설정은 특히 파일 확장자가 없거나 특이한 경우에도 서버-클라이언트 간의 통신이 안정적으로 이뤄지도록 보장한다.

## 4. S3 객체 URL 생성과 활용

S3 객체 URL은 파일 접근 경로로, 이미지를 웹에 삽입하거나 다운로드할 수 있다. S3 객체가 퍼블릭으로 설정된 경우, 누구나 해당 URL로 접근할 수 있으며, 비공개 설정된 경우에는 접근이 제한된다.

### A. 객체 URL 생성 방법

일반적으로 객체 URL은 다음과 같은 형식으로 구성된다.

```
https://{bucket-name}.s3.{region}.amazonaws.com/{object-key}
```

예를 들어, 버킷 이름이 `my-bucket`, 리전이 `us-east-1`, 객체 키(object key)가 `images/sample.jpg`라면, 객체 URL은 다음과 같다.

```
https://my-bucket.s3.us-east-1.amazonaws.com/images/sample.jpg
```

이 URL은 브라우저에서 직접 접근할 수 있는 링크이며, HTML 태그 내에 삽입하여 이미지 파일을 표시할 수 있다.

### B. 객체 URL 활용 예시

1. 웹 애플리케이션에서 이미지 표시: S3 객체 URL을 HTML 태그에 사용하여 이미지 파일을 웹 페이지에 삽입할 수 있다.

```html
<img src="https://my-bucket.s3.us-east-1.amazonaws.com/images/sample.jpg" alt="Sample Image">
```

2. 파일 다운로드 링크 제공: S3 객체 URL을 이용하여 다운로드 링크를 제공하면, 사용자가 클릭하여 파일을 다운로드할 수 있다.

```html
<a href="https://my-bucket.s3.us-east-1.amazonaws.com/images/sample.jpg" download>이미지 다운로드</a>
```

이처럼 S3 객체 URL을 활용하면 파일을 쉽게 공유하고 접근할 수 있다.

### C. Spring에서 S3 객체 URL 생성 방법

Spring에서 S3Client를 사용하여 객체 URL을 동적으로 생성하고 이를 활용할 수 있다. 파일 업로드 후, 해당 파일의 URL을 생성하는 코드를 작성하여 파일 접근 링크를 제공할 수 있다.

1. S3Client 설정: Spring에서 S3Client를 빈(bean)으로 설정한다.

```java
import java.beans.BeanProperty;

@Configuration
public class S3Config {

    @Bean
    public S3Client s3Client() {
        return S3Client.builder()
                .region(Region.US_EAST_1)
                .build();
    }
}
```

2. S3 객체 URL 생성 및 반환: S3Client를 사용하여 파일 업로드 후 해당 파일의 객체 URL을 반환하는 코드를 작성한다.

```java
@Service
public class S3Service {
    private final S3Client s3Client;
    
    public S3Service(S3Client s3Client) {
        this.s3Client = s3Client;
    }
    
    // 파일 업로드 메서드
    public String uploadFile(byte[] fileData, String bucketName, String fileName) {
        // S3에 파일 업로드
        PutObjectRequest putObjectRequest = PutObjectRequest.builder()
                .bucket(bucketName)
                .key(fileName)
                .build();
        
        s3Client.putObject(putObjectRequest, software.amazon.awssdk.core.sync.RequestBody.fromBytes(fileData));
        
        // 객체 URL 생성
        return generateObjectUrl(bucketName, fileName);
    }
    
    // 객체 URL 생성 메서드
    private String generateObjectUrl(String bucketName, String fileName) {
        return "https://" + bucketName + ".s3.amazonaws.com/" + fileName;
    }
}
```

3. 객체 URL 반환 사용 예시: 이미지 파일을 업로드한 후, S3 객체 URL을 반환하여 웹 애플리케이션에서 사용할 수 있도록 한다. 파일 업로드 후 해당 URL을 사용자에게 제공할 수 있다.

```java
@RestController
@RequestMapping("/s3")
public class S3Controller {
    private final S3Service s3Service;
    
    public S3Controller(S3Service s3Service) {
        this.s3Service = s3Service;
    }
    
    @PostMapping("/upload")
    public Map<String, String> uploadFile(@RequestParam("file") MultipartFile file) throws Exception {
        String bucketName = "my-bucket";
        String fileName = file.getOriginalFilename();
        
        // 파일 업로드 및 객체 URL 생성
        String objectUrl = s3Service.uploadFile(file.getBytes(), bucketName, fileName);
        
        // 결과 반환
        Map<String, String> result = new HashMap<>();
        result.put("objectUrl", objectUrl);
        
        return result;
    }
}
```

## 5. Presigned URL 사용 방법

### A. Presigned URL 개념 및 장점

Presigned URL은 보안이 중요한 파일을 안전하게 제공하기 위해 S3에 저장된 파일에 임시로 접근할 수 있는 URL을 생성하는 기능이다. 공개 접근이 제한된 객체에 대해 특정 시간 동안만 유효한 URL을 제공하며, 만료되면 더 이상 접근이 불가능하다. 따라서 파일을 비공개 상태로 유지하면서도 특정 사용자나 요청에 따라 안전하게 파일을 공유할 수 있다.

Presigned URL의 주요 장점은 다음과 같다.

1. 제한된 시간 동안만 접근 가능: 민감한 파일을 특정 시간 동안 특정 사용자에게만 제공할 수 있으며, URL이 만료되면 접근이 차단된다.
2. 버킷 권한 변경 없이 사용 가능: 버킷을 퍼블릭으로 설정하지 않고도 Presigned URL을 통해 임시 접근 권한을 제공하여 기본 보안 정책을 유지할 수 있다.
3. 간편한 통합: Presigned URL은 Spring 애플리케이션이나 다른 웹 서비스와 쉽게 통합되어, 특정 요청 시 URL을 동적으로 생성하여 보안을 강화할 수 있다.
4. 보안성 향상: 사용자는 Presigned URL을 통해서만 파일에 접근하므로 S3 버킷에 직접 접근할 필요가 없어 외부 사용자와 안전하게 파일을 공유할 수 있다.

Presigned URL은 다양한 사용 시나리오에 유용하게 활용될 수 있다.

* 민감한 데이터 전송: 사용자 데이터나 개인 정보가 포함된 파일을 일정 시간 동안만 공유하여 데이터 유출 위험을 줄일 수 있다.
* 제한된 파일 공유: 협업 프로젝트에서 외부 파트너나 고객에게 비공개 파일을 임시로 제공할 수 있다. 예를 들어, 2시간 동안 특정 보고서나 이미지를 다운로드할 수 있게 하여 보안을 유지한다.
* 클라이언트의 직접 파일 접근: 웹 애플리케이션에서 사용자가 S3에 직접 접근할 수 없게 Presigned URL을 통해 보안을 추가하고, 사용자는 안전하게 파일을 업로드하거나 다운로드할 수 있다.

### B. Presigned URL 생성 및 활용 예시

Presigned URL은 AWS SDK를 통해 간단히 생성할 수 있다. 다음은 Spring Boot 환경에서 S3Client를 사용하여 Presigned URL을 생성하는 예시이다.

```java
@Service
public class S3Service {
    private final S3Client s3Client;
    
    public S3Service(S3Client s3Client) {
        this.s3Client = s3Client;
    }
    
    public String generatePresignedUrl(String bucketName, String objectKey) {
        // Presigned URL의 유효 시간 설정 (예: 1시간)
        Duration expiration = Duration.ofHours(1);
        
        // Presigned URL 요청 생성
        PresignedGetObjectRequest presignedRequest = s3Client.presignGetObject(
                GetObjectRequest.builder()
                        .bucket(bucketName)
                        .key(objectKey)
                        .build(),
                PresignRequest.builder()
                        .signatureDuration(expiration)
                        .build()
        );
        
        // Presigned URL 반환
        return presignedRequest.url().toString();
    }
}
```

위 코드는 S3에 저장된 파일에 대해 1시간 동안만 유효한 Presigned URL을 생성하는 방법을 보여준다. 이 URL을 사용자에게 제공하면, 해당 사용자는 1시간 동안만 파일에 접근할 수 있으며, 이후에는 더 이상 접근할 수 없다.

생성된 Presigned URL은 다양한 방식으로 사용할 수 있다. 웹 애플리케이션 내에서 동적으로 생성하여 특정 사용자에게 제공하거나, 메일로 전송할 수 있다.

1. 웹 애플리케이션에서 다운로드 링크 제공

```html
<a href="https://my-bucket.s3.us-east-1.amazonaws.com/images/sample.jpg?X-Amz-Security-Token=..." download>임시 다운로드</a>
```

2. 이메일을 통한 파일 공유: 예를 들어, 고객이나 외부 파트너에게 특정 보고서나 자료를 이메일로 제공할 때, Presigned URL을 첨부하여 임시로 파일을 제공할 수 있다. 고객은 해당 URL을 클릭하여 파일에 접근할 수 있으며, 일정 시간이 지나면 접근 권한이 자동으로 소멸된다.

### C. Presigned URL의 한계

Presigned URL은 유용하지만, 사용 시 몇 가지 주의할 점이 있다. 이를 이해하고 대비하지 않으면 보안에 취약할 수 있다.

1. 만료 시간을 사용자에게 노출: Presigned URL은 생성 시 만료 시간을 명시해야 하며, 이 시간이 노출된다. 사용자가 URL을 받을 때, URL에 내장된 만료 시간이 포함되므로, 악의적인 사용자는 해당 URL을 남용하려고 시도할 수 있다. 즉, 만료 시간 내에 유출된 경우, URL을 통해 파일이 불법적으로 접근될 가능성이 있다.
2. 유효 시간이 지나면 접근 불가: 유효 시간이 지나면 URL을 다시 생성해야 한다. 사용자가 파일에 지속적으로 접근해야 하는 경우, 매번 새로운 URL을 발급해야 하는 불편함이 있을 수 있다. 특히, 유효 시간이 지나서 파일에 접근하려고 할 때, 사용자 경험이 떨어질 수 있다.
3. 추가적인 보안 조치가 부족: URL 자체에 대한 접근 제어는 없기 때문에, URL을 소유한 사람이 누군가에게 URL을 전달하면 누구든지 해당 URL을 통해 파일에 접근할 수 있다. 이는 유출된 URL에 대한 제어가 어렵다는 점에서 보안적인 취약점이 될 수 있다. 추가적으로 IP 기반의 접근 제어와 같은 다른 보안 조치를 추가로 적용하는 것이 필요할 수 있다.
4. 서버 성능에 부하 발생 가능성: 실시간으로 많은 사용자가 Presigned URL을 요청하면, URL을 동적으로 생성하는 과정에서 서버에 부하가 발생할 수 있다. 특히 대규모의 사용자에게 Presigned URL을 제공해야 하는 경우에는 서버 성능과 처리 속도에 영향을 미칠 수 있으며, 이로 인해 서비스가 지연될 수 있다.
5. URL의 취약점: Presigned URL이 일반 텍스트 URL 형태로 제공되므로, 누군가가 이 URL을 가로채거나 기록해두면 해당 유효 기간 내에 다시 사용할 수 있다. 따라서 네트워크 레벨에서 HTTPS를 통해 통신을 보호하는 것이 필수적이며, 추가적인 네트워크 보안이 필요하다.

## 6. CloudFront를 사용한 이미지 파일 접근

### A. CloudFront 소개

Amazon CloudFront는 AWS에서 제공하는 콘텐츠 전송 네트워크(CDN) 서비스로, 전 세계 사용자에게 빠르고 안정적으로 콘텐츠를 제공할 수 있도록 설계되었다. 특히, S3와 함께 사용하여 이미지 파일을 전 세계적으로 빠르게 전달하고, 대기 시간을 줄이는 데 효과적이다. 따라서 사용자 경험을 개선하고, 서버 부하를 줄일 수 있다.

CloudFront는 S3와 결합해 정적 파일을 엣지 로케이션에 캐싱해 빠르게 제공한다. 이미지 등 정적 자산을 빠르게 배포하는 데 유리하다.

### B. CloudFront의 주요 특징

1. 글로벌 네트워크: CloudFront는 전 세계에 200개 이상의 엣지 로케이션을 가지고 있어, 사용자의 지리적 위치와 상관없이 빠른 콘텐츠 제공이 가능하다. S3와 함께 사용하면, 사용자는 자신과 가장 가까운 엣지 로케이션에서 파일을 다운로드하거나 이미지 파일을 로드하게 된다. 이는 네트워크 레이턴시를 줄이고, 이미지 로딩 속도를 향상시킨다.
2. 콘텐츠 캐싱: CloudFront는 정적 파일을 엣지 로케이션에 캐싱하여 반복적인 요청에 대해 빠르게 응답할 수 있다. 예를 들어, 동일한 이미지 파일에 대해 여러 사용자가 요청할 때, S3에서 파일을 매번 가져오는 대신 CloudFront가 엣지 로케이션에 저장된 파일을 즉시 제공한다. 이로 인해 서버 부하가 감소하고 전송 속도가 크게 향상된다.
3. SSL/TLS 지원: CloudFront는 기본적으로 SSL/TLS를 지원하여 HTTPS를 통한 안전한 연결을 보장한다. 따라서 이미지 파일을 안전하게 전송할 수 있으며, 사용자와 서버 간의 통신 보안이 강화된다. 웹사이트에서 CloudFront를 통해 제공되는 모든 콘텐츠는 HTTPS로 암호화되어 전송된다.
4. 콘텐츠 압축: CloudFront는 Gzip과 같은 압축 기능을 지원하여 콘텐츠 크기를 줄여 전송한다. 특히, 이미지 외에도 CSS, JavaScript와 같은 정적 파일이 더 빠르게 로딩될 수 있다. 이 기능은 트래픽을 절감하고, 페이지 로딩 시간을 줄이는 데 기여한다.
5. 지리적 제한: CloudFront는 지리적 제한(Georestriction) 기능을 제공하여, 특정 국가나 지역에서 콘텐츠 접근을 차단하거나 허용할 수 있다. 따라서 특정 지역에만 이미지 파일을 제공하거나, 콘텐츠 저작권을 보호할 수 있다.
6. 프라이빗 콘텐츠 전송: CloudFront는 프라이빗 콘텐츠 전송 기능을 제공하여, 특정 사용자에게만 접근 권한이 있는 파일을 제공할 수 있다. S3와 결합하여, Presigned URL과 함께 사용할 경우, 제한된 사용자에게만 안전하게 이미지 파일을 제공할 수 있다.

### C. CloudFront 설정 및 S3와의 통합

CloudFront는 S3와 함께 사용될 때 성능과 보안 측면에서 더욱 강력해진다. 다음은 CloudFront와 S3를 통합하여 설정하는 과정이다.

1. S3 버킷 생성 및 이미지 업로드: AWS Management Console에서 S3 버킷을 생성하고 이미지 파일을 업로드한다. 이때 보안을 위해 퍼블릭 접근을 차단할 수 있지만, CloudFront를 통해 사용자들이 안전하게 파일에 접근할 수 있도록 설정할 수 있다.
2. CloudFront 배포 생성: AWS 콘솔에서 CloudFront 서비스를 선택한 후, Create Distribution을 클릭하여 새 배포를 생성한다. 이때 Origin Domain Name으로 S3 버킷을 선택하여 CloudFront가 해당 버킷의 콘텐츠를 캐싱할 수 있도록 설정한다. Origin Access Control(OAC)을 설정하면 CloudFront만이 S3 버킷에 접근할 수 있게 할 수 있다. 따라서 S3 버킷을 비공개로 유지하면서도 CloudFront를 통해 콘텐츠를 제공할 수 있다.
3. Cache Behavior 설정: Cache Behavior에서 Default TTL(Time to Live)을 설정하여 콘텐츠가 엣지 로케이션에서 얼마나 오래 캐싱될지를 결정할 수 있다. 자주 변경되지 않는 이미지 파일은 TTL을 길게 설정하여 CloudFront 캐시에서 빠르게 제공할 수 있도록 설정하는 것이 좋다.
4. HTTPS 및 접근 제어 설정: Viewer Protocol Policy를 Redirect HTTP to HTTPS로 설정하여 사용자들이 항상 HTTPS로 콘텐츠에 접근하도록 한다. Allowed HTTP Methods는 이미지 파일의 경우 GET, HEAD 메서드만 허용하는 것이 권장된다. 이는 불필요한 접근을 방지하고 보안을 강화하는 데 유리하다.
5. CloudFront 배포 완료: 설정이 완료되면 CloudFront 배포를 생성하고, 배포가 완료된 후 CloudFront의 도메인 이름을 통해 콘텐츠에 접근할 수 있다. 이 도메인을 사용하여 웹 애플리케이션에서 이미지 파일을 빠르게 로드할 수 있다. 

### D. CloudFront의 장점

CloudFront를 사용하면 이미지 파일을 더욱 빠르고 안전하게 제공할 수 있다. 주요 장점은 다음과 같다.

1. 성능 향상: CloudFront는 전 세계 사용자들에게 가장 가까운 엣지 로케이션에서 콘텐츠를 제공하므로, 사용자는 빠른 응답 시간을 경험할 수 있다. 이미지 파일과 같은 정적 자산은 CloudFront 캐싱 덕분에 빠르게 로딩되며, 사용자 경험이 크게 개선된다. 특히, 글로벌 서비스를 제공하는 웹 애플리케이션에서 CloudFront는 필수적인 성능 향상 도구로 작용한다.
2. 비용 절감: CloudFront를 통해 S3에서 발생하는 데이터 전송 비용을 절감할 수 있다. CloudFront는 S3로의 직접적인 요청을 줄여주기 때문에, S3에서 반복적으로 데이터를 가져오는 것보다 비용이 절감된다. 또한, CloudFront의 콘텐츠 캐싱 기능은 서버 부하를 줄여 결과적으로 인프라 비용을 줄여준다.
3. 보안 강화: CloudFront는 SSL/TLS 인증서를 통한 HTTPS 보안을 기본적으로 제공하며, AWS WAF(Web Application Firewall)와 통합하여 DDoS 공격을 방어할 수 있다. 또한, 지리적 제한 기능과 프라이빗 콘텐츠 전송 기능을 통해 민감한 이미지 파일의 접근을 제어할 수 있다. S3와 결합하여 Presigned URL을 사용할 경우, 특정 사용자에게만 제한된 시간 동안 파일을 제공하는 방식으로 보안을 강화할 수 있다.
4. 확장성: CloudFront는 AWS의 글로벌 인프라를 기반으로 대규모 트래픽을 쉽게 처리할 수 있다. 사이트에 갑작스럽게 많은 요청이 몰려도, CloudFront는 트래픽을 엣지 로케이션에 분산시켜 성능 저하 없이 안정적인 서비스를 제공한다. 따라서 대규모 트래픽이 예상되는 이벤트나 캠페인에서도 효율적으로 이미지를 제공할 수 있다.
5. 지리적 맞춤 제공: CloudFront는 지리적 제한 기능뿐만 아니라 지역 기반 제공(Geo-targeting) 기능을 제공하여, 특정 지역의 사용자에게 맞춤형 콘텐츠를 제공할 수 있다. 따라서 지역별로 다른 이미지나 광고를 제공할 수 있다. 예를 들어, 한국 사용자는 한국어 이미지를, 미국 사용자는 영어 이미지를 보게 하는 등 맞춤형 서비스가 가능하다.

## 7. 실제 서비스에 적용하기

<img width="698" alt="Untitled" src="https://github.com/user-attachments/assets/01dd26e4-b95d-4d68-824f-7d9a6c835d55">

실제 서비스에 적용해본다. 이 서비스는 사용자가 특정 장소나 상황에서의 기억과 경험을 '스타카토'라는 기록 형태로 저장할 수 있도록 설계되었다. 사용자는 제목과 장소 등의 필수 정보를 입력하고, 해당 순간을 더욱 생생하게 기록하기 위해 사진을 첨부할 수 있다. 사진은 요청을 통해 S3에 저장되며, 사용자는 카메라로 촬영하거나 갤러리에서 이미 촬영된 사진을 불러와 등록할 수 있다. 한 번에 최대 다섯 장까지 사진을 등록할 수 있으며, 필요에 따라 한 장씩 개별 등록하거나 여러 장을 한 번에 올릴 수 있다. 등록된 사진은 한 장씩 선택적으로 제거할 수 있다.

이때, 사진 등록과 삭제 과정에서 고려해볼 부분이 두 가지 있다.

### A. 스타카토 저장과 사진 등록 API의 분리 여부

필수 정보를 모두 입력하고 사진 등록을 마친 후 하나의 API를 호출해 스타카토를 저장하는 방식이 있다. 이때 API는 S3에 사진을 저장하고 S3 URL을 가져와 필수 정보와 함께 저장한다.

반면, 사진을 등록하자마자 별도의 API로 S3에 저장하고, 즉시 S3 URL을 반환받는 방식도 있다. 이후 필수 정보를 모두 입력한 후 S3 URL과 함께 스타카토를 저장하는 API를 호출하는 것이다.

이 두 방식은 사용자 경험에서 차이를 보인다. S3에 사진을 저장하는 데 1~3초가 걸린다고 가정할 때, 첫 번째 방식에서는 스타카토 저장 버튼을 누르고 3초를 기다려야 한다. 사용자에게는 스타카토 저장이 3초나 걸리는 것이 불편하게 느껴질 수 있다. 반면, 두 번째 방식에서는 사진 등록 시점에 S3에 저장을 진행하며 로딩 UI를 통해 사진 등록 진행 상황을 사용자에게 직관적으로 표시할 수 있다.

여기서 비동기적 처리 방식의 장점이 두드러진다. 사용자로 하여금 사진 등록 후 필수 정보를 입력하는 동안, 백그라운드에서 S3에 사진이 저장되도록 하여 전체적인 대기 시간을 최소화할 수 있다. 이는 사용자가 서비스 속도를 느끼는 방식에 영향을 주어, 마치 사진 등록이 더 빠르게 진행되는 것처럼 보이게 할 수 있다.

사진 로딩이 되는 동안 나머지 필수 정보들을 입력할 수 있게 만들었다. 이를 최대한 활용하려면 사용자가 사진 등록을 먼저 수행해야 하기 때문에, 의도적으로 사진 등록 UI를 가장 위쪽에 배치했다. S3에 사진을 저장하는데 걸리는 시간은 그대로 1~3초라 가정하고, 필수 정보들을 입력하는 시간을 5초라 가정한다. 이때 각각의 방법에 대해서 하나의 스타카토를 저장하는데 걸리는 시간은 다음과 같다.

* 첫 번째 방법: 5초(필수 정보 입력 시간) + 3초(S3에 저장을 기다리는 시간) = 8초
* 두 번째 방법: MAX(5초(필수 정보 입력 시간), 3초(S3에 저장을 기다리는 시간)) = 5초

스타카토 저장 API와 사진 등록 API를 분리하면, 하나로 관리하는 것보다 총 소요 시간이 짧아진다. 이로 인해 사용자는 정보 입력과 사진 등록이 동시에 진행되는 것으로 인식하게 되어, 대기 시간이 줄어든 듯한 사용자 경험을 제공할 수 있다.

API 요청이 실패하는 경우에서도 생각해볼 점들이 있다. 하나의 API로 관리하는 경우, 스타카토 저장이 실패하거나 하나의 사진 등록이 실패하거나 여러 장의 사진 등록이 실패하면 API 요청이 제대로 이루어지지 않는다. 이때, 사용자는 어떤 것 때문에 스타카토 저장이 실패했는지 알 수 없어 막연하게 재요청을 보내는 수밖에 없다. 반면에 API를 분리해서 관리하는 경우, 사진 등록이 실패하면 바로 직관적으로 실패한 부분을 확인할 수 있다. 이때는 해당 사진 등록만 재요청을 보내면 된다. 이렇게 각 과정이 독립적으로 처리되면, 오류 발생 시 사용자는 실패한 부분을 즉시 인지할 수 있어, 전체 작업을 반복하지 않고 특정 부분만 수정하여 재시도할 수 있다.

개발자 입장에서도 API 분리가 편하다. 하나의 API로 관리하는 경우, 스타카토 저장 과정에서 정확히 어느 로직에서 실패가 발생했는지 분석하는 과정이 필요하다. 필요한 경우 여러 장 중 어느 사진이 등록이 실패한 것인지와 같은 정보를 클라이언트 쪽에 전달해줘야 한다. 하지만 작은 단위의 로직 별로 API가 분리되어 있으면, 실패하는 로직을 명확하게 알 수 있고, 이에 대해서 실패 코드와 메시지를 관리하고 전달해주면 된다. 이렇게 분리된 API를 사용함으로써 실패 원인을 쉽게 파악할 수 있고, 불필요한 코드 복잡성 없이 효과적으로 에러 처리를 할 수 있다. 개발 측면에서도 유지보수성이 강화되며, 특히 비동기 처리를 위한 예외 상황 로직을 보다 간단하게 작성할 수 있다.

또한, AWS S3는 저장 요청마다 비용이 발생하기 때문에, 특정 사진 등록이 실패할 경우 전체 스타카토 저장을 취소하기보다는 실패한 사진 등록만 재요청하여 불필요한 추가 비용 발생을 막을 수 있다. 여러 장의 사진이 한꺼번에 저장될 때 개별 요청을 통해 비용을 최적화하는 것이 가능하여, 서비스 운영 측면에서도 경제적인 선택일 수 있다.

### B. 사진 등록 API에서 한 번에 처리하는 사진의 개수

사진 등록 API를 분리했다면, 해당 API에서 한 번에 여러 장의 사진을 처리할 것인지 아니면 한 장씩만 처리할 것인지 결정해야 한다. 이 결정은 S3에 사진을 저장하는 도중 저장 실패가 발생하는 경우를 대비하는 데 중점을 두고 이루어진다.

사진 저장이 실패하면 실패한 사진이 무엇인지 클라이언트에 알려주어야 한다. 그래야 클라이언트가 사용자에게 해당 사진 요청을 재시도하도록 유도할 수 있다. 만약 API에서 한 번에 여러 장의 사진을 처리하고 있었다면, 어떤 사진이 실패했는지를 알아내는 로직이 추가로 필요하다. 알아냈다면 일부가 성공한 요청에 대해서 응답의 상태 코드는 무엇으로 할지, 실패한 사진의 S3 URL은 어떤 식으로 줄지에 대해서 클라이언트와 의논해서 적절하게 결정해야 한다. 특히, 실패한 사진과 성공한 사진을 개별적으로 반환하려면 복잡한 로직이 필요해지고, 오류 처리를 위한 추가 작업이 발생한다.

반면에, API에서 한 장의 사진만 처리한다면, 앞에서 언급했던 모든 것들을 따로 고려할 필요가 없다. 해당 API가 성공했으면 성공했다는 응답, 실패했다면 실패했다는 응답을 보내면 되므로, 각 요청마다 단순하고 명확한 결과를 클라이언트에 전달할 수 있다. 이렇게 하면 실패한 사진만 간단히 재요청할 수 있어, 로직의 복잡성이 줄어들고 유지 보수성은 강화된다. 따라서 로직의 복잡성을 낮추고 유지 보수성을 강화하는 효과를 기대할 수 있다.

또한, 소요되는 총 시간에 대해서도 비교해 볼 필요가 있다. S3에 사진을 저장하는 시간 자체는 두 방법 모두 비슷하겠지만, 한 장의 사진만 처리하는 경우에는 다섯 장을 등록하기 위해 다섯 번의 API 요청이 발생한다. 이는 클라이언트와 서버 사이의 네트워크를 여러 번 오가게 만들어 네트워크 대기 시간이 더해질 수 있다. 그러나 사진 등록 API와 스타카토 저장 API를 분리했다면, 각각의 사진 등록 요청이 성공했는지 여부가 사용자에게 UI로 즉각 피드백 될 수 있고, 동시에 사용자 역시 스타카토 정보를 입력하고 있는 상황일 것이다. 이런 방식은 개별 사진의 등록 완료 여부를 실시간으로 보여줌으로써 네트워크 대기 시간이 사용자 경험에 미치는 부정적인 영향을 줄일 수 있다. 즉, 총 소요 시간의 차이가 사용자 경험에 있어 큰 의미를 갖지 않게 된다.

결론적으로, 네트워크 대기 시간의 미미한 차이보다는 API 로직의 단순성, 유지 보수의 용이성, 실패 시 직관적인 피드백의 중요성에 가치를 두어 한 번에 하나의 사진만 처리하는 API 방식을 선택했다. 따라서 서비스는 보다 직관적이고, 사용자 입장에서 혼란을 줄일 수 있는 방향으로 설계했다.

### C. 사진 삭제 시 S3의 객체 삭제 여부

사진 등록 API를 분리하여 사진을 등록하면 즉시 S3에 저장되도록 구현함으로써 사용자 경험 측면에서 이점을 챙겼지만, 여기에는 사진 삭제 시 고려할 문제도 존재한다. 등록한 사진을 삭제할 때, 만약 S3에 저장된 객체를 실제로 삭제하도록 구현했다면, 다음과 같은 과정이 필요하다. 삭제 API를 클라이언트에서 서버로 보내고, 서버가 S3에 객체 삭제 요청을 전송하고, S3에서 해당 객체를 찾아 삭제한 뒤 다시 서버에 응답을 보내고, 서버는 이를 클라이언트에 전달하는 일련의 절차가 요구된다. 이 과정은 필연적으로 지연 시간이 발생하며, 특히 등록한 사진을 삭제할 때 로딩이 길어질 경우 사용자 경험에 부정적 영향을 미칠 수 있다.

따라서 이러한 문제를 해결하기 위해 삭제 요청이 들어오면 클라이언트 측에서 S3 URL을 단순히 삭제하는 방식으로 접근했다. 클라이언트에서 S3 URL을 삭제하면, 실제 S3에 저장된 객체는 그대로 남아 있지만, 서버로는 해당 URL이 전송되지 않으므로 결과적으로 애플리케이션 DB에는 삭제된 사진이 저장되지 않게 된다. 이 방식의 장점은 서버와의 통신 없이 즉각적으로 삭제 효과를 사용자에게 보여줄 수 있으며, 사용자 측면에서는 사진 삭제가 매우 빠르고 직관적이라는 느낌을 받을 수 있다는 것이다.

그러나 실제 S3 객체가 삭제되지 않기 때문에 S3에는 클라이언트에서 삭제된 사진들이 그대로 남아 누적되는 문제점이 발생한다. 결과적으로 시간이 지나면 DB에 등록된 S3 URL 개수보다 S3에 남아 있는 사진이 더 많아지는 문제가 발생한다. 이러한 잉여 객체는 S3의 스토리지 용량을 불필요하게 차지하게 되고, S3 사용량에 따른 비용 부담을 증가시키는 원인이 될 수 있다.

이 문제를 해결하기 위해 주기적인 S3 객체 정리 작업을 도입할 계획이다. 구체적으로는 AWS Lambda를 활용하여 정기적으로 DB에 저장된 URL 목록과 S3에 실제로 존재하는 객체 목록을 비교하고, DB에 없는 URL에 해당하는 S3 객체는 자동으로 삭제하는 로직을 구현할 예정이다. Lambda 함수는 일주일에 한 번과 같이 주기적으로 실행되도록 설정하여, S3에 쌓이는 불필요한 객체를 효과적으로 정리할 수 있게 된다. 따라서 S3 저장 공간을 최적화하고 비용을 절감하는 효과를 기대할 수 있다.

이와 같은 방식은 삭제 요청 시 사용자 경험을 향상시키면서도, 백엔드에서 주기적인 정리를 통해 S3 객체 관리 문제를 해결하는 전략적 접근으로, 사용자 경험과 서비스 운영 측면에서 모두 긍정적인 결과를 기대할 수 있다.

## 8. 마무리

이 글을 통해 Amazon S3와 CloudFront를 활용하여 이미지 파일을 효율적으로 관리하고 배포하는 방법을 알 수 있다. S3는 데이터의 확장성, 내구성, 그리고 비용 효율성을 제공하며, CloudFront는 글로벌 사용자에게 빠르고 안정적인 콘텐츠를 제공할 수 있도록 지원한다. 특히, Presigned URL과 같은 기능을 통해 보안을 강화하면서도 편리하게 파일을 공유할 수 있다는 점에서 강력한 도구로 활용할 수 있다.

향후 프로젝트에서는 이러한 기능들을 적용하여, 특히 대규모 이미지 파일 관리나 글로벌 서비스 제공에 있어 큰 도움을 받을 수 있다. AWS 콘솔로 S3와 CloudFront를 테스트해 최적의 성능을 구현할 수 있다.

추가적으로 이미지 파일 관리에 있어 비용 절감을 위해 S3 스토리지 클래스를 적절하게 선택하거나, CloudFront의 캐싱 정책을 최적화하는 등의 방법도 고려해볼 수 있다. 또한, 보안을 더욱 강화하기 위해 지리적 제한이나 WAF 통합을 통한 공격 방어도 함께 고민할 필요가 있다.

## 9. 참고

1. [Amazon S3 공식 문서](https://docs.aws.amazon.com/s3/): Amazon S3에 대한 기본 개념과 다양한 기능을 다룬 공식 문서이다. S3 버킷 설정, 객체 저장, 보안 옵션, 스토리지 클래스 등에 대해 더 깊이 있게 학습할 수 있다.
2. [Amazon CloudFront 공식 문서](https://docs.aws.amazon.com/cloudfront/): Amazon CloudFront의 기본 개념과 설정 방법을 다룬 공식 문서이다. CloudFront와 S3를 통합하는 방법, 캐싱 정책, HTTPS 설정 등 세부적인 설정 방법에 대해 학습할 수 있다.
3. [Presigned URL 공식 가이드](https://docs.aws.amazon.com/AmazonS3/latest/userguide/ShareObjectPreSignedURL.html): Amazon S3에서 Presigned URL을 사용하여 보안성을 강화하고, 특정 사용자에게만 파일 접근 권한을 부여하는 방법을 다룬 가이드이다.
