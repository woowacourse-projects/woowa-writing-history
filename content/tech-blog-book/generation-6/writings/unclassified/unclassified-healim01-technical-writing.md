---
author: "healim01"
generation: 6
level: "unclassified"
original_filename: "technical-writing.md"
source: "https://github.com/woowacourse/woowa-writing/blob/healim01/technical-writing.md"
source_path: "technical-writing.md"
---

# 우리 팀에게 적합한 전역 상태 라이브러리는 뭘까?

### 부제 : 전역 상태 관리의 필요성과 적절한 라이브러리 선택법

### 1. 서론

현대 웹 애플리케이션이 복잡해지면서, 애플리케이션 안에 컴포넌트들의 상태 공유 또한 복잡해졌으며 효율적인 관리가 필수적이게 되었습니다. 특히 로그인 상태, 사용자 설정, 테마 등 전역적으로 필요한 데이터를 효율적으로 관리하지 않으면 데이터 흐름이 복잡해지고 버그가 발생하기 쉽습니다. 전역 상태 관리 도구를 사용하면 이러한 데이터를 중앙에서 관리해 유지보수를 쉽게 할 수 있습니다.

상태 관리는 사용자 경험(UX)과 직결되며, 장바구니 같은 애플리케이션에서 상태가 제대로 관리되지 않으면 사용자에게 혼란을 줄 수 있습니다. 상태가 복잡해지면 데이터 불일치, 상태 전파의 복잡성, 유지보수 어려움이 발생합니다. 이러한 문제를 해결하는 것이 전역 상태 관리의 핵심입니다.

### 2. 전역 상태 관리란?

전역 상태 관리(Global State Management)란 애플리케이션 전반에 걸쳐 여러 컴포넌트에서 공유되고 사용할 수 있는 **중앙 집중식 상태 관리 방식**입니다. 이는 애플리케이션의 상태를 한 곳에서 관리하고, 각 컴포넌트가 해당 상태에 접근하거나 변경할 수 있도록 하는 패턴입니다.

일반적인 리액트에서 상태를 관리할 때 가장 기본적인 방법인 **컴포넌트의 지역 상태는** 각 컴포넌트 내부에서만 관리되고, 그 컴포넌트에 국한된 데이터입니다.
만약 상태를 전달하기 위해 **props**를 사용할 수 있습니다. 하지만 props는 단방향 데이터 흐름이기 때문에, 상위에서 하위로만 전달될 수 있습니다. 이때 각 하위 컴포넌트에 직접적으로 관련 없는 중간 컴포넌트를 거쳐서 props를 계속 전달해야 한다면, 관리가 복잡해지고 코드가 비효율적으로 변할 수 있습니다.

이러한 상황에서 전역 상태 관리는 상태를 한 곳에서 관리하고, 각 컴포넌트가 필요한 상태를 중앙에서 직접 가져와 사용하게 하여 props drilling 문제를 해결해줍니다. 더 이상 중간 컴포넌트를 거쳐 props를 전달할 필요 없이, 어디서든 상태에 접근할 수 있습니다.

<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/healim01/img/props.png" width="500px"/>

### 2.1. 전역 상태 관리의 정의

전역 상태 관리(Global State Management)란 애플리케이션 전반에 걸쳐 여러 컴포넌트에서 공유되고 사용할 수 있는 **중앙 집중식 상태 관리 방식**입니다. 이는 애플리케이션의 상태를 한 곳에서 관리하고, 각 컴포넌트가 해당 상태에 접근하거나 변경할 수 있도록 하는 패턴입니다.

리액트 같은 프론트엔드 라이브러리에서는 주로 컴포넌트별로 **지역 상태(Local State)**를 관리하지만, 애플리케이션이 커질수록 여러 컴포넌트가 동일한 상태에 의존하는 상황이 생깁니다. 이때 전역 상태 관리를 사용하면 상태가 중복되지 않고, 중앙에서 쉽게 관리할 수 있습니다.

전역 상태 관리의 주요 목적은 **상태 공유**와 **상태 일관성 유지**입니다. 예를 들어, 사용자 인증 상태나 테마 설정 같은 전역적으로 사용되는 상태는 개별 컴포넌트에서 각각 관리하기보다는, 전역 상태로 중앙에서 관리하는 것이 더 효율적입니다. 이를 통해 **컴포넌트 간 데이터 전달**과 **상태 일관성** 문제를 해결할 수 있습니다.

### 2.2. 상태와 props의 차이

리액트 애플리케이션에서 상태를 관리할 때 가장 기본적인 방법인 **컴포넌트의 지역 상태는** 각 컴포넌트 내부에서만 관리되고, 그 컴포넌트에 국한된 데이터입니다. 리액트에서는 `useState`와 같은 훅을 사용해 상태를 선언하고 업데이트합니다.

그러나 **props**는 부모 컴포넌트가 자식 컴포넌트로 데이터를 전달할 때 사용하는 메커니즘입니다. props를 통해 상태를 전달하면, 하위 컴포넌트에서도 해당 데이터를 사용할 수 있습니다. 하지만 props는 단방향 데이터 흐름이기 때문에, 상위에서 하위로만 전달될 수 있습니다.

전역 상태 관리와 지역 상태(혹은 props)의 주요 차이는 다음과 같습니다:

- **지역 상태 (Local State)**:
  - 각 컴포넌트 내부에서만 관리되고 사용할 수 있습니다.
  - 상태가 변화해도 해당 컴포넌트에만 영향을 미칩니다.
  - 다른 컴포넌트에서 해당 상태를 사용하려면 props를 통해 전달해야 합니다.
- **전역 상태 (Global State)**:
  - 애플리케이션 전체에서 공유되고, 모든 컴포넌트가 접근할 수 있는 상태입니다.
  - 상태가 변경되면 그 상태를 참조하는 모든 컴포넌트에 자동으로 반영됩니다.
  - 상태를 여러 컴포넌트에서 쉽게 접근하고 변경할 수 있습니다.
- **Props**
  - 상위 컴포넌트에서 하위 컴포넌트로만 데이터를 전달할 수 있다.

이러한 차이로 인해 컴포넌트 계층 구조가 깊어질수록 props로 상태를 전달하는 것이 불편해질 수 있으며, 이러한 문제를 해결하기 위해 전역 상태 관리가 필요해집니다.

Props 로 데이터를 전달할 때 발생하는 **Props drilling**

<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/healim01/img/props.png" width="500px"/>

<br/>

---

### 3. 전역 상태 관리의 필요성

### 3.1. 상태 공유

애플리케이션이 커지면서, 상태를 여러 컴포넌트에 props로 전달하는 방식은 유지보수에 어려움을 겪을 수 있습니다. 예를 들어, 사용자의 로그인 상태가 필요한 네비게이션 바, 프로필 페이지, 대시보드 등에서 이를 각각 props로 전달하는 것은 관리가 복잡해집니다. 이때 전역 상태 관리를 도입하면, 상위 컴포넌트에서 props를 계속 전달할 필요 없이 중앙 상태에서 직접 로그인 상태에 접근할 수 있게 되어 더 간편해집니다.

**전역 상태 관리**를 도입하면, 모든 컴포넌트가 하나의 중앙 상태에서 로그인 상태를 쉽게 접근하고 사용할 수 있습니다. 컴포넌트가 어떤 위치에 있든 전역 상태에 바로 접근할 수 있기 때문에, 상태를 공유하는 작업이 매우 간단해지고 유지보수가 쉬워집니다.

### 3.2. 복잡한 애플리케이션

상태 관리는 애플리케이션이 복잡해질수록 더욱 중요해집니다. 예를 들어, 배달의 민족과 같이 배달 서비스를 생각해 봅시다. 여기서는 장바구니 상태, 사용자 인증 상태, 가게 목록, 필터링 옵션, 결제 정보 등 여러 상태를 관리해야 합니다. 이때 모든 상태를 개별 컴포넌트 내부에서 관리하거나, props로 전달하는 방식은 복잡성과 오류를 초래할 수 있습니다.

복잡한 애플리케이션에서 전역 상태 관리는 다음과 같은 이점을 제공합니다:

1. **상태 일관성 유지**: 애플리케이션의 여러 곳에서 동일한 상태를 참조하고 있다면, 이 상태가 변경되었을 때 모든 컴포넌트에서 자동으로 업데이트됩니다. 예를 들어, 장바구니에 음식을 추가했을 때, 장바구니 UI뿐만 아니라 상품 목록이나 결제 페이지에서도 자동으로 반영되도록 할 수 있습니다.
2. **코드 간소화**: props로 상태를 전달하는 방식을 사용하면 상위 컴포넌트가 하위 컴포넌트로 props를 계속해서 전달해야 하므로 컴포넌트 계층 구조가 깊어질수록 복잡해집니다. 하지만 전역 상태 관리를 사용하면 이런 복잡한 props 체인을 피할 수 있어 코드가 단순해지고 유지보수성이 높아집니다.
3. **재사용성**: 전역 상태는 여러 컴포넌트에서 공유되기 때문에, 중복된 로직을 줄이고 코드의 재사용성을 높일 수 있습니다. 상태를 중앙에서 관리하기 때문에, 컴포넌트마다 동일한 상태 관리 로직을 작성할 필요가 없습니다.

React 생태계에는 이러한 이점을 가진 Zustand, Redux, Recoil 같은 다양한 전역 상태 라이브러리들이 있습니다. 각 도구는 상태 관리의 복잡성을 줄이고, 애플리케이션 전반에서 쉽게 상태를 공유할 수 있게 도와줍니다.
<br/>

---

### 4. 전역 상태 관리 라이브러리 소개

전역 상태 관리 라이브러리는 다양한 애플리케이션에서 상태를 효율적으로 관리하는 데 도움이 됩니다. 각 라이브러리는 특정 목적이나 사용 사례에 맞게 최적화되어 있어, 프로젝트 요구 사항에 맞는 라이브러리를 선택하는 것이 중요합니다. 여기서는 대표적인 전역 상태 관리 라이브러리인 **Redux**, **Zustand**, 그리고 **Recoil**에 대해 살펴보겠습니다.

### 4.1. Redux

**Redux**는 가장 널리 사용되는 전역 상태 관리 라이브러리 중 하나로, 리액트뿐만 아니라 다양한 자바스크립트 애플리케이션에서 사용할 수 있습니다.
Redux는 애플리케이션 상태를 하나의 중앙 저장소에서 관리하며, 상태 변화는 **액션(action)**과 **리듀서(reducer)**를 통해 이루어집니다. 모든 상태 변화가 명시적으로 관리되기 때문에, 상태를 예측 가능하고 쉽게 디버깅할 수 있습니다

### 4.1.1. 특징 및 장점

1. **예측 가능한 상태 관리**: Redux는 애플리케이션 상태를 하나의 중앙 저장소(store)에서 관리하며, 상태 변화는 모두 **액션**(action)과 **리듀서**(reducer)를 통해 이루어져 상태 변화를 명시적이고 디버깅하기 쉽게 만듭니다.
2. **시간 여행 디버깅(Time Travel Debugging)**: Redux DevTools를 사용하면 상태 변화의 히스토리를 추적할 수 있고, 이전 상태로 되돌아가거나 재생(replay)할 수 있습니다. 이 기능은 복잡한 애플리케이션에서 매우 유용합니다.
3. **미들웨어 지원**: Redux는 **thunk**나 **saga** 같은 미들웨어를 통해 비동기 로직을 처리할 수 있는 강력한 확장성을 제공합니다.

### 4.1.2. 단점 및 사용 시 고려 사항

1. **복잡한 보일러플레이트 코드**: 액션, 리듀서, 디스패처 등의 초기 설정이 복잡하고 보일러플레이트 코드가 많아질 수 있습니다. 특히, 작은 프로젝트나 간단한 상태 관리에는 과도할 수 있습니다.
2. **학습 곡선**: Redux의 개념(액션, 리듀서, 미들웨어 등)을 익히는 데 시간이 걸릴 수 있습니다. 상태 관리에 익숙하지 않은 개발자에게는 진입 장벽이 높을 수 있습니다.
3. **구조의 유연성 부족**: 모든 상태가 하나의 중앙 저장소에 저장되기 때문에, 상태 관리가 커지면 store가 복잡해질 수 있습니다. 이를 해결하기 위해 코드 분할이나 리듀서 분리 등의 작업이 필요할 수 있습니다.

<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/healim01/img/redux.png" width="500px"/>

<br/>

---

### 4.2. Zustand

**Zustand**는 경량 상태 관리 라이브러리로, 보다 간단하고 효율적인 전역 상태 관리를 제공합니다. Redux의 복잡성을 피하고 싶은 개발자들에게 매우 좋은 옵션입니다.

### 4.2.1. 특징 및 장점

1. **간단한 API**: Zustand는 불필요한 보일러플레이트 코드가 거의 없어 매우 가벼운 상태 관리 라이브러리입니다. 상태를 설정하고 사용할 때 단순한 함수 호출만으로 쉽게 구현할 수 있어, Redux와 비교해 매우 직관적입니다.
2. **선언적 사용**: Zustand는 리액트 훅(Hook)을 사용해 선언적으로 상태를 정의합니다. 상태를 저장하고 읽는 것이 리액트 훅 사용 방식과 일관되므로, 리액트 환경에서 쉽게 적용할 수 있습니다.
3. **구독 기반 시스템**: Zustand의 구독 기반 시스템은 상태의 특정 부분만 구독할 수 있어, 상태 변화가 일어난 부분만 리렌더링됩니다. 이를 통해 불필요한 전체 리렌더링을 방지하고 특히 큰 애플리케이션에서 성능 최적화에 크게 기여합니다. 예로, 쇼핑몰 애플리케이션에서 장바구니 상태가 변경될 때, 필요한 컴포넌트만 업데이트되어 성능 개선이 가능합니다.
4. **비동기 처리의 간결성**: Redux와 달리, Zustand는 비동기 상태 변경도 간단하게 처리할 수 있으며, 미들웨어 설정 없이도 비동기 로직을 쉽게 다룰 수 있습니다.
 
<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/healim01/img/zustand.png" width="500px"/>

<br/>

---

### 4.3. Recoil

**Recoil**은 Facebook에서 개발한 전역 상태 관리 라이브러리로, 리액트와의 통합에 초점을 맞추고 있습니다. 특히 리액트의 동작 방식과 자연스럽게 맞물리도록 설계되었습니다.

### 4.3.1. 특징 및 장점

1. **간단한 상태 및 파생 상태 관리**: Recoil은 **Atom**(상태의 최소 단위)과 **Selector**(파생 상태를 계산하는 함수)를 통해 상태를 관리하며, 이를 통해 복잡한 상태와 의존성을 쉽게 다룰 수 있습니다.
2. **리액트와의 자연스러운 통합**: Recoil은 리액트의 기본 개념과 매우 밀접하게 연관되어 있으므로, 리액트 개발자에게 직관적이고 사용하기 쉽습니다. 특히, 리렌더링 성능을 최적화하는 데 효과적입니다.
3. **동시성 및 비동기 데이터 처리**: Recoil은 비동기 상태 관리를 자연스럽게 지원하며, Selector를 이용해 파생 상태의 의존성과 캐싱을 효율적으로 관리할 수 있습니다.

### 4.3.2. 단점 및 사용 시 고려 사항

1. **학습 곡선**: Recoil의 개념은 리액트와 밀접하게 연관되어 있지만, Atom과 Selector 개념을 처음 접하는 개발자들에게는 약간의 학습이 필요할 수 있습니다

<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/healim01/img/recoil.png" width="500px"/>

---

### 5. 상태 관리 라이브러리 비교

전역 상태 관리 라이브러리는 프로젝트의 규모, 복잡성, 팀의 기술 스택에 따라 선택해야 합니다. 각 라이브러리마다 장단점이 있으며, 특정 상황에 더 적합한 도구가 존재합니다.

이 섹션에서는 **Redux**, **Zustand**, **Recoil**를 중심으로 상태 관리 라이브러리의 장단점을 비교하도록 하겠습니다.

### 5.1. Redux vs. Zustand

| 비교 항목               | Redux                                           | Zustand                                             |
| ----------------------- | ----------------------------------------------- | --------------------------------------------------- |
| **설정 및 사용**        | 초기 설정이 복잡하고 보일러플레이트 코드가 많음 | 간결하고 직관적인 설정, 보일러플레이트가 적음       |
| **디버깅 및 개발 도구** | Redux DevTools 지원으로 시간 여행 디버깅 가능   | Redux DevTools 지원으로 시간 여행 디버깅 가능       |
| **비동기 처리**         | 미들웨어(thunk, saga)를 통해 비동기 로직 관리   | 간단한 API로 비동기 처리 가능                       |
| **프로젝트 규모**       | 대규모 프로젝트에서 유용                        | 작은 프로젝트에서 적합하지만 대규모에서도 사용 가능 |

- **Redux**는 대규모 애플리케이션이나 복잡한 상태 관리가 필요한 경우에 더 적합합니다. 하지만 초기 설정이 복잡하여 러닝 커브가 있습니다.
- **Zustand**는 간결함과 사용 편의성을 제공하므로, 설정과 유지보수에서 효율성이 중요한 소규모 프로젝트에 적합합니다. 복잡하지 않은 상태 관리에는 Zustand가 더 나은 선택이 될 수 있습니다.

<br/>

### 5.2. Redux vs. Recoil

| 비교 항목          | Redux                                                   | Recoil                                           |
| ------------------ | ------------------------------------------------------- | ------------------------------------------------ |
| **리액트 통합성**  | 리액트 외 다른 프레임워크와도 통합 가능                 | 리액트와의 긴밀한 통합으로 설계됨                |
| **상태 관리 방식** | 중앙 집중식 상태 관리, 모든 상태가 하나의 스토어에 저장 | Atom과 Selector를 통한 분산된 상태 관리          |
| **비동기 처리**    | 미들웨어를 사용해 비동기 처리                           | 기본적으로 비동기 처리를 지원하고 캐싱 기능 제공 |
| **성능**           | 상태 변화에 따른 리렌더링이 발생할 수 있음              | 구독 기반 시스템으로 필요한 부분만 다시 렌더링   |
| **복잡성**         | 복잡한 보일러플레이트 코드가 존재                       | 상대적으로 간결하며, 상태 의존성 관리가 용이함   |

- **Redux**는 리액트 외의 다른 프레임워크에서도 사용할 수 있는 범용 상태 관리 라이브러리로, 다양한 미들웨어와 확장성을 제공합니다. 대규모 애플리케이션이나 비동기 처리가 복잡한 애플리케이션에 적합합니다.
- **Recoil**은 리액트와의 통합성을 강조하며, 보다 직관적이고 상태 관리가 분산된 방식으로 진행됩니다. 상태 의존성이 복잡한 리액트 애플리케이션에서 성능과 개발 경험을 크게 향상시킬 수 있습니다.

<br/>

### 5.3. Zustand vs. Recoil

| 비교 항목         | Zustand                                                     | Recoil                                                     |
| ----------------- | ----------------------------------------------------------- | ---------------------------------------------------------- |
| **설정 및 사용**  | 매우 간단하고 보일러플레이트가 거의 없음                    | 비교적 간단하지만 일부 초기 설정이 필요                    |
| **비동기 처리**   | 비동기 상태 관리를 간단한 API로 처리 가능                   | `selector`와 `atom`을 통한 비동기 상태 관리 지원           |
| **상태 구조**     | 상태 구조가 자유로워 작은 프로젝트에 적합하지만 확장성 있음 | `atom`과 `selector` 구조로 대규모 애플리케이션에 적합      |
| **프로젝트 규모** | 소규모에서 대규모 프로젝트까지 유연하게 사용 가능           | 대규모 프로젝트에서 더욱 적합하며, 복잡한 상태 관리에 유리 |

- **Zustand**는 가볍고 빠른 상태 관리를 제공하며, **Recoil**은 복잡한 상태 의존성과 비동기 처리가 필요한 리액트 프로젝트에 최적화된 선택입니다.

<br/>

### 5.4. 라이브러리 총 정리

- **Redux**: 대규모 애플리케이션, 팀 간 협업이 잦고 상태 관리가 복잡한 경우 적합합니다. 미들웨어로 비동기 로직을 쉽게 처리하고, Redux DevTools로 디버깅을 원활하게 할 수 있습니다.
- **Zustand**: 설정이 간단하고 가벼운 상태 관리가 필요한 소규모 프로젝트에서 사용하기 좋습니다. 빠르게 상태를 정의하고 사용해야 하는 경우 적합합니다.
- **Recoil**: 상태의 의존성이 많은 복잡한 리액트 애플리케이션에서 사용하기 적합합니다. 리액트와의 자연스러운 통합이 강점이며, 비동기 데이터 처리와 캐싱 기능이 필요한 프로젝트에 유용합니다.

<br/>

---

### 6. 모든 걸 전역 상태로 진행하면 되는걸까?

설명한 것처럼 전역 상태 관리는 매우 유용하지만, 모든 상태를 전역으로 관리하는 것은 좋지 않습니다. 모든 상태를 전역으로 관리하면 불필요한 리렌더링이 발생하고, 애플리케이션의 복잡성이 증가할 수 있습니다.

일반적으로 **여러 컴포넌트에서 공유해야 하는 상태**나 **전역적으로 유지해야 할 중요한 데이터**만 전역 상태로 관리하고, **개별 컴포넌트 내부에서만 필요한 상태**는 로컬로 유지하는 것이 성능과 유지보수에 유리합니다.

따라서 전역 상태 관리는 **필요한 곳에서만 적절하게 사용**하는 것이 바람직하며, 모든 상태를 전역으로 처리하는 것은 피해야 합니다.

<br/>

---

### 7. **결론**

전역 상태 관리는 오늘날의 복잡한 애플리케이션에서 매우 중요한 역할을 합니다. 이를 통해 여러 컴포넌트 간에 상태를 효율적으로 공유하고 관리할 수 있으며, 잘 설계된 상태 관리 구조는 애플리케이션의 유지보수성과 성능을 크게 향상시킵니다.

특히 **Zustand**, **Redux**, **Recoil**과 같은 다양한 전역 상태 관리 라이브러리는 각각의 특성과 장단점을 가지고 있어, 애플리케이션의 요구 사항에 맞는 적합한 도구를 선택하는 것이 중요합니다.
