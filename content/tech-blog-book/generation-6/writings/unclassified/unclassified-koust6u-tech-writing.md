---
author: "koust6u"
generation: 6
level: "unclassified"
original_filename: "tech-writing.md"
source: "https://github.com/woowacourse/woowa-writing/blob/koust6u/tech-writing.md"
source_path: "tech-writing.md"
---

# HTTP에 대한 필수 지식

## 서론

최근 프로젝트를 진행하며 HTTP 프로토콜에 대한 이해 부족과 다양한 의견으로 인한 논쟁을 자주 경험하게 되었습니다. 따라서 이 글에서는 웹 애플리케이션 개발에서 필수적으로 알아야 할 HTTP의 기본 개념과 초보자가 쉽게 접할 수 있는 오류에 대해 설명하고, 이를 바탕으로 더 나은 HTTP API 설계 방안을 제시하고자 합니다.

이 글은 HTTP의 깊이 있는 학습보다는 실무에서 유용한 기반 지식과 필수적인 HTTP 개념에 집중합니다.

### 1 HTTP란?

HTTP(HyperText Transfer Protocol)는 하이퍼텍스트를 전송하는 통신 규약입니다. 하이퍼텍스트는 문서 내 특정 단어에 링크가 걸려 다른 문서나 시스템으로 연결되는 형태로, HTTP는 이러한 하이퍼텍스트를 효율적으로 전송하는 방법에 대한 규칙을 제공합니다.

### 1.1 HTTP의 초기 역사

HTTP는 1991년 버전 0.9로 시작하여 현재 3.0까지 여러 번 개정되며 발전해 왔습니다. 초기 HTTP는 문서 전송을 목적으로 만들어졌습니다. 1989년 유럽 입자 물리학 연구소(CERN)에서 팀 버너스 리가 문서 공유의 어려움을 해소하고자 제안한 HTTP는 기본적인 URL 구조와 HTML 형식을 포함하며 시작되었습니다.

- **HTTP 0.9 (1991)**: 단순히 GET을 통해 문서를 조회할 수 있는 기능만 제공했습니다.
- **HTTP 1.0 (1996)**: W3의 수요가 증가하면서 POST와 HEAD 메서드가 추가되고 상태 코드 및 헤더 개념이 도입되었습니다.
- **HTTP 1.1 (1997)**: 대용량 트래픽을 효율적으로 처리하기 위해 지속 연결, 파이프라이닝, 캐시 기능이 추가되었습니다.

초기 HTTP의 발전을 통해 웹의 급속한 성장과 함께 HTTP가 필요에 맞게 발전해왔음을 알 수 있습니다.


## 1.2 HTTP의 기본 개념

HTTP의 작동 방식을 이해하기 위해 알아야 할 두 가지 기본 개념이 있습니다.

1. **클라이언트-서버 모델**: HTTP는 요청-응답 구조로, 클라이언트가 서버에 요청을 보내고, 서버가 이에 응답하는 방식으로 작동합니다. 이는 문서를 요청하고 응답하는 HTTP의 핵심 구조입니다.

2. **무상태성 (Stateless)**: HTTP는 클라이언트의 상태 정보를 서버에 저장하지 않기 때문에 각 요청은 독립적으로 처리됩니다. 이로 인해 서버는 각 요청을 새로운 것으로 간주하고, 클라이언트의 이전 요청 정보를 기억하지 않습니다. 이러한 무상태성은 서버의 부하를 줄이고 구조를 단순화합니다.

## 2. HTTP 주요 구성 요소

### 2.1 URI와 URL


URI와 URL은 개념적으로 유사하지만 차이점이 있습니다. URL은 URI의 하위 개념으로, 자원의 위치를 명시하는 식별자입니다. URL을 통해 웹 브라우저는 특정 웹 페이지나 파일에 접근할 수 있으며, URL은 다음 요소로 구성됩니다.

- **스키마(Scheme)**: 통신할 프로토콜을 나타냅니다.
- **도메인 이름(Domain Name)**: 통신할 서버의 이름입니다.
- **포트(Port)**: HTTP는 기본적으로 80번 포트를 사용합니다.
- **파일 경로(Path)**: 서버에서 리소스의 위치를 나타냅니다.
- **파라미터(Parameters)**: 특정 리소스의 형식을 제한하거나 정보를 추가하는 데 사용됩니다.

---

이 글은 HTTP의 기본 개념과 발전 과정을 소개하고, 이를 통해 실무에서 효과적으로 활용할 수 있는 지식을 제공하는 데 목적이 있습니다. HTTP의 주요 개념을 정확히 이해함으로써 웹 애플리케이션 개발의 기반을 다지길 바랍니다.

**2.2 메서드**

팀 내에서 메서드에 대한 일관성이 깨지는 경우가 많았던 이유는 메서드에 대한 이해가 부족했기 때문입니다. 이를 해결하기 위해 각 메서드의 개념을 명확하게 파악해 보겠습니다.

**[GET]**

GET 요청은 URL로 식별되는 자원을 요청할 때 사용됩니다. GET 요청을 보낼 때는 리소스를 생성하는 과정이 아닌 생성된 결과만 반환해야 합니다.

예를 들어, `GET http://localhost:80/user` 요청 시 사용자를 생성하는 SQL이 실행된다면, 결과로 insert 쿼리 과정이 아닌 생성된 사용자 데이터만 반환되어야 합니다.

GET 요청에는 기본적인 GET 외에도 조건부 GET, 부분적 GET 요청이 있습니다.

- **조건부 GET**  
  HTTP 1.1에서는 `If-Modified-Since`, `If-Unmodified-Since`, `If-Match`, `If-None-Match`, `If-Range`와 같은 헤더를 통해 GET 요청을 조건부로 수행합니다.

  예를 들어, `If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT` 헤더가 추가된 요청은 2015년 10월 21일 이후에 자료가 변경된 경우에만 리소스를 반환합니다.

- **부분적 GET**  
  `Range` 헤더를 사용해 응답 받을 리소스의 범위를 제한할 수 있습니다.

  예를 들어, `Range: bytes=0-499` 헤더가 추가된 `GET http://localhost:80/user` 요청은 응답으로 첫 500 바이트까지만 받습니다.

**[POST]**

POST 메서드는 요청한 정보를 서버의 새로운 리소스로 수락하는 요청입니다. 요청 URL로 식별된 리소스의 하위 리소스가 생성됩니다. 쉽게 말해, 서버에 새로운 리소스를 등록하기 위한 요청입니다.

**[HEAD]**

HEAD 메서드는 GET 요청과 동일한 응답을 Body를 제외하고 반환합니다. 주로 API의 유효성 검증이나 Header 정보를 얻기 위해 사용됩니다.

**[PUT]**

PUT 요청도 POST와 같이 특정 URL에 리소스를 추가하지만, 요청 URL이 직접 해당 리소스를 가리킨다는 점에서 차이가 있습니다.

- 예:
  ```http
  POST /api/posts HTTP/1.1
  ```
  위 요청은 새로운 post가 추가되지만 `/api/posts` 자체가 해당 리소스를 나타내지는 않습니다.

  반면, 아래의 요청은 URL이 생성될 리소스를 직접 의미합니다.
  ```http
  PUT /api/posts/1 HTTP/1.1
  ```
**[PATCH]**

PATCH 메서드는 리소스의 일부만 업데이트할 때 사용됩니다. PUT과 유사하지만, PUT이 리소스 전체를 업데이트하는 것과 달리, PATCH는 특정 필드만 수정할 수 있는 점에서 차이가 있습니다. 이를 통해 전체 리소스를 보내지 않고도 부분적인 업데이트를 수행할 수 있어 효율적입니다.

- 예:
  ```http
  PATCH /api/posts/1 HTTP/1.1
  Content-Type: application/json
  ```
  요청 Body에 수정할 데이터만 포함하여 특정 필드를 업데이트할 수 있습니다.

PATCH는 API 클라이언트와 서버 간 통신을 효율적으로 유지할 때 유용하며, 일반적으로 JSON 포맷을 사용하여 업데이트할 필드를 지정합니다.

**[DELETE]**

DELETE는 URL로 식별되는 리소스를 삭제 요청하지만, 서버에서 삭제 여부를 판단해 삭제할 수도 있습니다. 클라이언트는 200번대 상태 코드로 삭제 결과를 확인할 수 있습니다.

**[TRACE]**

TRACE는 주로 네트워크 진단 및 디버깅에 사용됩니다. 예를 들어, 요청에 `Max-Forwards` 헤더를 설정해 몇 번의 중계 서버를 거쳐야 하는지 지정할 수 있습니다. 요청한 정보가 그대로 반환되므로 보안상 권장되지 않습니다.

**[CONNECT]**

CONNECT는 SSL 전환을 위한 터널링에 사용됩니다.


**주의사항**
PUT, POST, PATCH 메서드는 모두 서버에 데이터를 추가하거나 변경하는 데 사용되지만, 각 메서드가 적용되는 상황과 사용 시 주의사항은 다릅니다.

### **POST**
- **목적**: 서버에 새로운 리소스를 추가합니다.
- **특징 및 주의사항**:
  - **비멱등성**: 동일한 요청을 여러 번 보내면 서버에 중복된 데이터가 생성될 수 있습니다.
  - **서버의 자동 생성 ID**: 서버가 자동으로 리소스의 ID를 생성하여 새로운 리소스를 저장하고 URI를 반환하는 경우가 많습니다.
  - **예시**: `POST /api/posts` 요청은 서버가 새로운 리소스를 생성하며, 응답으로 새 리소스의 URI (`/api/posts/1` 등)를 보낼 수 있습니다.
- **사용 예시**:
  ```http
  POST /api/posts HTTP/1.1
  Content-Type: application/json

  {
    "title": "New Post",
    "content": "This is a new post."
  }
  ```

### **PUT**
- **목적**: 지정된 URL의 리소스를 생성하거나 전체를 업데이트합니다.
- **특징 및 주의사항**:
  - **멱등성**: 동일한 요청을 여러 번 보내도 서버의 상태는 동일하게 유지됩니다. 즉, 여러 번 호출하더라도 같은 상태를 보장합니다.
  - **전체 업데이트**: 리소스 전체를 업데이트해야 합니다. 만약 일부 필드만 포함된 요청을 보낸다면 나머지 필드는 비워지거나 덮어쓰여 문제가 생길 수 있습니다.
  - **리소스 위치 명확성**: `PUT /api/posts/1`과 같이 URI로 리소스를 명확히 식별할 수 있어야 하며, 해당 URI가 리소스의 위치를 직접 가리킵니다.
- **사용 예시**:
  ```http
  PUT /api/posts/1 HTTP/1.1
  Content-Type: application/json

  {
    "title": "Updated Post",
    "content": "This post has been updated."
  }
  ```

### **PATCH**
- **목적**: 리소스의 일부만 업데이트합니다.
- **특징 및 주의사항**:
  - **비멱등성**: 멱등성을 보장할 수도 있지만, 부분 업데이트 내용에 따라 다를 수 있습니다.
  - **부분 업데이트**: 리소스 전체가 아닌 일부 필드만 수정할 때 사용하며, 전체 데이터를 다시 전송하지 않고 변경할 부분만 보냅니다.
  - **JSON Patch 등 규격**: 일반적으로 JSON Patch와 같은 규격을 사용해 수정할 필드를 명확히 지정합니다.
  - **주의사항**: 일부 서버는 PATCH 메서드를 지원하지 않을 수 있습니다. 또한 잘못된 필드를 전달하면 예상치 못한 데이터 불일치가 발생할 수 있습니다.
- **사용 예시**:
  ```http
  PATCH /api/posts/1 HTTP/1.1
  Content-Type: application/json

  {
    "title": "Partially Updated Title"
  }
  ```


### **요약**
| 메서드 | 용도 | 특징 | 주의사항 |
|--------|------|------|----------|
| **POST** | 새 리소스 생성 | 비멱등성, 서버가 ID 생성 | 요청 반복 시 중복 생성 가능 |
| **PUT** | 리소스 전체 업데이트 | 멱등성, 전체 리소스 갱신 필요 | 전체 데이터를 포함하지 않으면 기존 필드 덮어씀 |
| **PATCH** | 리소스 일부 업데이트 | 비멱등성 (상황에 따라 멱등 가능) | 서버 지원 여부 확인, 일부 필드 수정 시 데이터 불일치 주의 |

각 메서드는 목적에 맞는 사용과 주의사항을 따르는 것이 중요하며, 이를 통해 데이터 일관성을 유지하고 효율적인 API 설계를 할 수 있습니다.


---

**2.3 세션(Session)과 쿠키(Cookie)**

HTTP는 무상태성 프로토콜로, 이를 보완하기 위해 세션과 쿠키가 사용됩니다.

**쿠키(Cookie)**  
쿠키는 클라이언트에 저장되는 작은 데이터로, 주로 다음과 같은 목적으로 사용됩니다.

- **세션 관리**: 로그인 정보 유지
- **개인화**: 사용자 설정 기억
- **트래킹**: 웹사이트 방문 기록 추적

쿠키의 주요 속성:

- `Expires`: 만료 시간 지정
- `Secure`: HTTPS를 통해서만 전송
- `HttpOnly`: 자바스크립트에서 접근 불가, 보안 강화

**세션(Session)**  
세션은 서버에서 관리되는 상태 정보로, 사용자가 로그인하거나 중요한 정보를 교환할 때 서버에 생성됩니다. 클라이언트는 세션 ID라는 고유 식별자를 통해 서버에서 상태를 유지합니다.

세션의 주요 특징:

- **서버 측에서 관리**: 클라이언트에서 수정할 수 없음
- **짧은 수명**: 브라우저를 닫거나 일정 시간이 지나면 만료
- **보안성**: 쿠키보다 보안성이 높음

**쿠키와 세션의 차이점**

- **저장 위치**: 쿠키는 클라이언트 측, 세션은 서버 측
- **보안성**: 쿠키는 보안에 취약, 세션은 서버에서 관리되어 더 안전
- **수명**: 쿠키는 만료 시간 설정 가능, 세션은 일반적으로 브라우저가 종료되거나 일정 시간이 지나면 만료

HTTP는 무상태성이지만, 세션을 통해 클라이언트를 식별할 수 있습니다.


---

### 3. 멱등성 (Idempotency)

HTTP API 설계에서 서버의 안정성을 높이기 위해 중요한 개념 중 하나인 멱등성은 요청을 여러 번 보내도 결과가 달라지지 않는 특성을 뜻합니다. 이러한 특성은 웹 애플리케이션의 예측 가능성과 안정성을 높여주는 역할을 합니다.

#### 3.1 안전한 메소드 (Safe Methods)
안전한 메소드는 서버의 상태를 변경하지 않는 메소드로, 주로 **GET**과 **HEAD**가 해당됩니다. 이 메소드들은 리소스를 조회하는 것이 목적이기 때문에, 서버의 상태를 바꾸지 않아야 합니다. 웹 애플리케이션 설계 시 개발자는 이러한 안전한 메소드의 목적을 유지하는 것이 중요합니다.

#### 3.2 멱등 메소드 (Idempotent Methods)
멱등 메소드는 여러 번 호출해도 서버의 최종 상태가 동일하게 유지되는 메소드입니다. 주요 멱등 메소드는 **GET**, **HEAD**, **PUT**, **DELETE** 등이 있으며, 각각의 동작은 아래와 같습니다:

- **GET**: 정보를 가져오는 메소드로 여러 번 호출해도 서버의 상태는 변하지 않으며, 동일한 응답을 반환합니다.
- **HEAD**: GET과 유사하게 헤더 정보만 반환합니다.
- **PUT**: 자원을 생성하거나 업데이트할 때 사용되며, 동일한 자원에 대해 여러 번 PUT 요청을 보내도 최종 결과는 동일합니다.
- **DELETE**: 자원을 삭제하는 메소드로, 동일한 자원에 대해 여러 번 DELETE 요청을 보내도 첫 번째 요청 이후에는 삭제할 자원이 없습니다.

멱등성은 사용자에게 일관된 경험을 제공하는 데 중요한 요소이며, 서버 설계에서 고려되어야 할 필수 사항입니다.

---

### 4. CORS (교차 출처 리소스 공유)

CORS는 한 출처에서 로드된 웹 페이지가 다른 출처의 자원에 접근할 수 있도록 허용하는 메커니즘입니다. 기본적으로 웹 브라우저는 Same-Origin Policy(SOP)를 따르는데, 이는 보안상의 이유로 다른 출처의 자원 접근을 제한하는 정책입니다. CORS는 서버에서 허용한 특정 출처에 대해 이러한 제한을 완화합니다.

#### 4.1 CORS 작동 원리
CORS는 **HTTP 헤더**를 통해 클라이언트가 다른 출처에 요청할 수 있도록 허용합니다. 주요 헤더는 다음과 같습니다:

- **Access-Control-Allow-Origin**: 허용된 출처를 지정합니다. `*` 설정 시 모든 출처를 허용합니다.
- **Access-Control-Allow-Methods**: 허용되는 HTTP 메소드를 지정합니다.
- **Access-Control-Allow-Headers**: 요청 시 사용할 수 있는 헤더를 지정합니다.
- **Access-Control-Allow-Credentials**: 인증 정보를 포함한 요청을 허용합니다.
- **Access-Control-Max-Age**: Preflight 요청 결과를 캐시할 시간을 지정합니다.

#### 4.2 CORS의 종류
CORS 요청은 **Simple Requests**와 **Preflight Requests**로 나뉩니다.

- **Simple Requests**: GET, POST, HEAD 메소드를 사용하고, 추가적인 Preflight 요청이 필요하지 않습니다.
- **Preflight Requests**: PUT, DELETE와 같이 안전하지 않은 메소드를 사용할 때 OPTIONS 메소드로 서버에 허용 여부를 확인하는 요청을 먼저 보냅니다.

---

### 결론

HTTP의 작동 방식과 설계 원리를 이해함으로써 안정적이고 효율적인 웹 애플리케이션을 개발할 수 있습니다. 다양한 HTTP 관련 기술을 습득하고, 실제 프로젝트에서 발생하는 문제를 해결해 나가며, 더 나은 웹 개발자로 성장할 수 있기를 바랍니다.

---

참고 자료 
[RFC2616](https://datatracker.ietf.org/doc/html/rfc2616)
[HTTP 완벽 가이드](https://m.yes24.com/Goods/Detail/15381085)
