---
author: "dobby-kim"
generation: 6
level: "unclassified"
original_filename: "technical-writing.md"
source: "https://github.com/woowacourse/woowa-writing/blob/dobby-kim/tech-writing/technical-writing.md"
source_path: "tech-writing/technical-writing.md"
---

# 분산 환경에서 even하게 일관성 지키기, 그런데 Kafka를 곁들인


**작성자**: 김도엽 (도비)

**대상 독자**: 
1. 분산 환경에서 발생하는 문제점에 대해서 알아보고 싶은 개발자
2. 분산 DB와 시스템 아키텍처가 도입된 서비스의 서버 개발자 및 관리자
3. Kafka에 대한 기본 개념과 그 용법에 대해서 알고 싶은 개발자

**활용 계획**: 개발 블로그 포스팅


---
## 목차
1. 분산 환경에서의 DB 일관성 개요
   - 분산 환경이란?
   - DB 일관성이란?
   - 분산 환경에서의 DB 일관성 문제

2. 일관성을 보장하기 위한 전략과 도구
   - CAP 이론과 일관성
   - ACID vs BASE 모델
   - 분산 트랜잭션 관리
   - 이벤트 소싱과 CQRS
3. Kafka를 활용한 분산 환경에서의 일관성 관리
   - Kafka란?
   - Kafka를 통한 데이터 일관성 보장
   - Kafka Streams와 실시간 처리
4. 배달 서비스에서의 Kafka 사용 예시
5. 끝으로
---

 우아한테크코스를 진행하면서 `100만 사용자가 있을 때`를 가정하여 고가용성을 위해 DB를 분리했을 때 발생하는 동시성 및 지연복제 문제 해결, 성능 측정을 요구하는 등 여러 요구사항을 만족시키기 위해 다양한 시도를 진행했습니다. 
 이것에 이어 서비스가 발전하면서 고가용성 아키텍쳐의 필요성이 생기면서 발생할 수 있는 여러 상황에 대해 관심을 가지고 생각해보기 시작했습니다.
기존의 여러 서비스에서 사용하고 있는 Kafka에 대해 알게 되었고, 이 Kafka가 왜, 어떻게 사용되는지 공부해보며 알게된 내용을 정리해보았습니다.

## 1. 분산 환경에서의 DB 일관성 개요

글에 들어가기에 앞서, `분산 환경`과 `DB 일관성`에 대해 간단하게 짚고 넘어가 보겠습니다.

### 1.1 분산 환경이란?

![img.png](https://raw.githubusercontent.com/woowacourse/woowa-writing/dobby-kim/tech-writing/img.png)
>출처: Microsoft Learn


**분산 환경**은 여러 노드(서버, 데이터베이스 등)가 네트워크로 연결되어 하나의 시스템처럼 상호작용을 하는 아키텍처를 말합니다. 이런 시스템은 노드 간의 상호작용을 통해 데이터 처리와 저장이 분산되어 이루어지는데, 이것을 통해 확장성과 가용성을 높일 수 있습니다. 하지만 물리적 네트워크 지연이나 노드 장애 등으로 인해 데이터 일관성을 보장하는 것이 어려운 단점이 존재합니다.

분산 시스템은 흔히 대규모 서비스에서 사용됩니다. Google, Amazon, Netflix와 같은 큰 규모의 웹 서비스들이 대표적인 예입니다. 예를 들어, 음식 배달 서비스를 떠올려보겠습니다.
A라는 고객이 서울에서 음식을 주문했을 때, 그 주문 내역은 여러 지역에 분산된 서버들을 통해 전송되고 관리됩니다. 동시에 수많은 고객이 다른 위치에서 주문을 하기 때문에, 데이터 일관성 문제가 발생할 가능성이 큽니다. 이런 상황에서 데이터가 언제나 최신 상태로 일관되게 유지되는 것이 중요합니다.

### 1.2 DB 일관성이란?



**DB 일관성**이란 데이터베이스가 트랜잭션 수행 전후에 항상 유효한 상태를 유지하는 성질입니다. 데이터베이스 일관성이 보장되면, 사용자가 시스템에 접속하여 데이터를 조회하거나 수정할 때 오류가 없는 안정적인 데이터를 볼 수 있습니다.
여기서도 예를 들어 보겠습니다. 음식 배달 서비스에서 A 고객이 특정 레스토랑에서 음식을 주문할 때, 주문이 성공적으로 접수되어야만 레스토랑 측에서 해당 주문을 준비할 수 있습니다. 만약 주문 과정에서 트랜잭션이 중간에 실패한다면, 고객의 주문이 실제로는 처리되지 않았지만 레스토랑은 주문을 준비하는 상황을 방지해야 합니다. 데이터베이스는 전체 트랜잭션이 완료되기 전까지 변경 사항을 확정하지 않음으로써 일관성을 유지합니다.

또한 온라인 쇼핑몰에서도 동일한 상황이 발생할 수 있습니다. 고객이 상품을 결제하려고 할 때, 결제 트랜잭션이 완료되지 않은 경우, 해당 상품이 다른 고객에게 잘못 판매되지 않도록 일관성을 유지하는 것이 중요합니다.


분산 환경에서는 여러 노드가 동시에 데이터를 처리하므로, 단일 서버에서 일관성을 유지하는 것보다 더 많은 복잡성이 수반됩니다. 서로 다른 서버가 데이터를 동시에 처리할 때, 데이터가 불일치하는 상황을 어떻게 해결할지 고민해야 합니다.

이를 이해하기 위해 **CAP 이론**과 **ACID, BASE 모델**이 등장했습니다. 이 모델들에 대한 설명은 뒤에서 등장하는 개념들과 함께 설명하고자 합니다.



### 1.3 분산 환경에서의 DB 일관성 문제


그렇다면 분산 환경에서 어떤 경우에 앞서 설명한 DB 일관성에 대한 문제가 발생할 수 있을까요?
음식 배달 서비스를 다시 생각해 보겠습니다. 여러 고객이 동시에 같은 레스토랑에서 음식을 주문하거나, 주문 상태가 여러 서버에 걸쳐 관리될 때, 그 정보는 모든 서버에 일관되게 전달되어야 합니다. 하지만 네트워크 지연, 노드 장애, 데이터 복제 등 다양한 이유로 데이터가 일관되지 않게 될 위험이 존재합니다.

그리고 이런 분산 시스템에서 일관성 문제가 발생하는 주요 원인은 다음과 같습니다.


1. **네트워크 지연**: 분산된 서버들이 서로 다른 지역에 있을 때, 네트워크를 통해 데이터를 주고받는 시간이 발생합니다. 
   ex) 서울에 있는 서버와 부산에 있는 서버가 서로 데이터를 동기화할 때 약간의 지연이 발생할 수 있습니다. 그 사이에 고객이 주문 상태를 변경한다면, 데이터가 일시적으로 일치하지 않는 문제가 생길 수 있습니다.

2. **노드 장애**:특정 서버가 다운되었을 때, 그 서버에서 처리하던 요청이 손실되거나 동기화되지 않는 문제가 발생할 수 있습니다. 

   ex) 온라인 쇼핑몰에서 결제 완료 버튼을 누른 시점에 서버가 다운되었다면, 재고 정보가 제대로 반영되지 않을 수 있겠죠?

3. **데이터 복제**: 분산 시스템에서는 데이터를 여러 서버에 복제하여 저장하는 경우가 많습니다.
   ex) A 서버에서 데이터를 수정했는데, B 서버에 해당 수정 사항이 즉각 반영되지 않으면 데이터가 불일치하게 됩니다. 이를 방지하기 위해 데이터 복제본 간의 일관성을 유지하는 기술이 필요합니다.



이러한 문제를 해결하기 위해서는 분산 시스템의 특성에 맞는 데이터 일관성 보장 기법이 필요합니다.

그리고 이를 설명하기 위해 많은 방법론과 여러 개념이 고안되었지만, 이 글에서는 **CAP 이론**과 **ACID, BASE 모델**에 대해 다뤄보고자 합니다.



## 2. 일관성을 보장하기 위한 전략과 도구


### 2.1 CAP 이론과 일관성


**CAP 이론**은 분산 시스템에서 **일관성(Consistency)**, **가용성(Availability)**, **파티션 허용성(Partition Tolerance)** 이라는 세 가지 속성을 모두 동시에 만족시킬 수 없음을 설명합니다. CAP 이론은 분산 시스템에서 네트워크 파티션이 발생할 경우, 세 가지 중 두 가지만 보장할 수 있다고 합니다. 즉, 일관성을 유지하려면 가용성이나 파티션 허용성을 어느 정도 포기해야 하고, 가용성을 우선할 경우 일관성을 약화할 수밖에 없습니다.
![img_2.png](https://raw.githubusercontent.com/woowacourse/woowa-writing/dobby-kim/tech-writing/img_2.png)

조금 더 쉬운 예시를 들어 설명하자면, 다음과 같이 설명할 수 있겠습니다.
 음식 배달 서비스에서 네트워크에 문제가 발생한 경우, 주문 상태를 모든 고객과 레스토랑에 일관되게 보여주기 위해서는 가용성을 포기하고 잠시 주문 처리를 중단해야 할 수 있습니다. 반면, 고객에게 빠른 응답을 제공하기 위해 가용성을 우선할 경우, 모든 노드에 동일한 주문 상태가 즉시 반영되지 않을 수 있습니다.


• **일관성(Consistency)**: 모든 노드에서 동일한 데이터를 확인할 수 있는 상태를 말합니다. 예를 들어, 사용자가 한 노드에서 데이터를 업데이트하면, 즉시 다른 노드에서도 같은 변경 사항을 볼 수 있어야 합니다.

• **가용성(Availability)**: 시스템의 일부가 장애를 겪더라도 계속해서 요청에 응답할 수 있는 성질입니다. 즉, 항상 시스템이 동작하고 있어야 합니다.

• **파티션 허용성(Partition Tolerance)**: 네트워크상의 일부 노드 간 통신이 실패하더라도 시스템이 계속 작동하는 성질입니다. 이는 대규모 분산 시스템에서 흔히 발생하는 문제로, 일부 노드가 네트워크에서 분리되더라도 시스템이 전체적으로 작동해야 합니다.



이 이론에서 각 특성의 우선순위를 결정하는 것이 시스템 설계의 핵심입니다.

금융 시스템에서는 일관성을 우선시하는 것이 중요합니다. 사용자의 잔액이 항상 정확해야 하기 때문입니다. 반면, 소셜 미디어에서는 가용성이 더 중요한 요소일 수 있습니다. 사용자가 '좋아요'를 누른 게시물이 즉시 반영되지 않더라도, 전체 시스템은 계속 작동할 수 있어야 합니다.

이렇게 각 전략은 서비스의 성격을 고려하여 신중하게 선정되어야 합니다.


### 2.2 ACID vs BASE 모델


**ACID**와 **BASE** 모델은 데이터베이스 트랜잭션 처리 방식의 두 가지 대표적인 모델입니다.


• **ACID 모델**은 전통적인 데이터베이스 트랜잭션에서 사용하는 원칙으로, 이름을 이루고 있는 각 글자는 다음과 같습니다.

- **Atomicity(원자성)**
- **Consistency(일관성)**
- **Isolation(고립성)**
- **Durability(지속성)**


이 모델이 적용된 트랜잭션은 은행 거래와 같은 강력한 일관성이 필요한 환경에서 주로 사용된다고 합니다. 예를 들어, 은행에서 계좌 간 이체를 할 때, 돈이 중간에 사라지지 않도록 중간에 문제가 발생해도 모든 과정이 원자적으로 완료되거나 전혀 이루어지지 않도록 보장됩니다.

 반면, BASE 모델은 일관성을 다소 느슨하게 처리하면서 가용성을 우선시하는 방식으로, 온라인 쇼핑몰처럼 실시간으로 수많은 요청을 처리해야 하는 시스템에 적합합니다. 예를 들어, 사용자가 상품을 장바구니에 추가할 때, 일시적으로 최신 상태가 아니더라도 최종적으로 모든 데이터가 일치하게 되는 것을 목표로 합니다.

이렇듯 **BASE 모델**은 분산 시스템에서 자주 사용되는 방식입니다. 이름이 어떻게 이루어져있는지 살펴보자면,

- **Basically Available(기본적인 가용성)**
- **Soft state(일시적인 비일관성 허용)** 
- **Eventual consistency(최종적 일관성)**

으로 이루어져있다고 하네요.

이는 일관성보다는 가용성을 우선시하며, 분산 시스템에서 데이터가 시간이 지나면 결국 일관성을 가지게 되는 것을 목표로 합니다.
그렇다면, 음식 배달 서비스에서도 BASE 모델의 접근이 유용할 수 있습니다. 여러 고객이 동시에 주문할 때, 일시적으로 모든 고객에게 동일한 주문 상태를 보장하기 어려울 수 있지만, 시간이 지나 최종적으로 일관된 상태를 유지하면 시스템의 가용성과 사용자 경험을 높일 수 있겠습니다!



### 2.3 분산 트랜잭션 관리

분산 트랜잭션 관리는 여러 노드에서 발생하는 트랜잭션을 원자적으로 처리하기 위한 방법입니다. 분산 환경에서는 단일 데이터베이스 트랜잭션처럼 간단히 처리할 수 없기 때문에, 이를 위해 2PC(2-Phase Commit) 와 3PC(3-Phase Commit) 같은 프로토콜이 사용됩니다.

![img_1.png](https://raw.githubusercontent.com/woowacourse/woowa-writing/dobby-kim/tech-writing/img_1.png)

**2PC(2-Phase Commit)**:
트랜잭션을 두 단계로 나누어 처리하는 방법입니다. 먼저 각 노드에 트랜잭션을 준비시키고(prepare), 모든 노드가 준비되면 트랜잭션을 커밋(commit)하여 완료합니다. 이는 모든 노드가 준비 완료 상태일 때만 트랜잭션이 성공적으로 완료되는 방식으로, 원자성을 보장합니다. 그러나 2PC는 네트워크 장애나 노드 고장 시 전체 시스템이 블록되거나 교착 상태에 빠질 수 있다는 단점이 있습니다.

배달 서비스에서 고객이 음식을 주문할 때, 결제가 성공적으로 이루어져야 주문이 접수됩니다. 만약 결제 과정에서 네트워크 오류가 발생하여 트랜잭션이 중단되면, 고객의 결제가 완료되지 않은 상태로 시스템이 블락될 수 있습니다. 이는 데이터 일관성을 보장하지만, 가용성을 저하시킬 위험이 있습니다.

**3PC(3-Phase Commit):**
3PC는 트랜잭션을 세 단계로 나누고, 타임아웃 및 중간 단계(pre-commit)를 추가하여 일부 노드의 응답이 없을 때 시스템이 교착 상태에 빠지지 않도록 설계되었습니다. 2PC보다 복잡하지만 장애에 대한 대응력을 높여 시스템의 가용성을 일부 보장합니다. 특히 분산 시스템에서 교착 상태를 방지하기 위한 타임아웃 메커니즘이 추가되어 있어, 시스템이 블록되지 않고 복구 가능하도록 돕습니다.

온라인 커머스에서 고객이 상품을 결제하는 동안 서버 장애가 발생할 경우, 3PC는 트랜잭션을 중간 단계에서 롤백하거나 타임아웃을 통해 다음 단계를 유연하게 처리할 수 있어 고객이 잘못된 결제 정보를 받는 것을 방지합니다.

이러한 분산 트랜잭션 관리 방식은 여러 서버에서 트랜잭션을 안전하게 처리할 수 있도록 돕지만, 네트워크 지연이나 노드 장애 발생 시 성능 저하가 불가피합니다. 이를 보완하기 위해 최근에는 이벤트 기반 아키텍처와 **멱등성(Idempotency)** 을 결합한 접근 방식을 많이 사용합니다. 이는 복잡한 트랜잭션을 간소화하고, 실패 시 이벤트를 재처리하여 데이터 일관성을 유지하도록 합니다.


### 2.4 이벤트 소싱과 CQRS

이벤트 소싱(Event Sourcing) 과 CQRS(Command Query Responsibility Segregation) 는 분산 시스템에서 데이터 일관성을 유지하는 또 다른 방법입니다.

**이벤트 소싱(Event Sourcing)**: 

데이터의 변경 사항을 이벤트로 저장하는 방식입니다. 이 방식에서는 데이터의 최종 상태를 저장하는 대신, 데이터가 변경된 모든 이벤트를 기록하고, 필요한 경우 이벤트를 재생하여 최종 상태를 복원할 수 있습니다. 이를 통해 데이터의 변경 이력을 모두 추적할 수 있고, 복구 시점에서 데이터의 정확성을 보장합니다.

 배달 서비스에서 고객이 주문을 할 때, 주문 변경 사항을 모두 이벤트로 기록합니다. 고객이 주문을 취소하거나 변경하면, 이벤트를 통해 변경 내역을 기록하고, 필요한 경우 이벤트를 재생하여 정확한 주문 상태를 복원할 수 있습니다. 이를 통해 고객과 배달원 모두에게 일관된 주문 정보를 제공합니다.


하지만 여기서 발생할 수 있는 문제는 다음과 같을 수 있습니다.

이벤트 소싱은 모든 이벤트를 저장하므로, 데이터의 볼륨이 매우 커질 수 있습니다. 따라서 저장소 관리와 효율적인 이벤트 재생을 위한 성능 최적화가 중요합니다.


**CQRS(Command Query Responsibility Segregation)**:

읽기 작업과 쓰기 작업을 분리하여 처리하는 아키텍처입니다. 쓰기 작업은 데이터 변경을 담당하고, 읽기 작업은 조회를 위한 최적화된 데이터를 제공합니다. 이를 통해 복잡한 트랜잭션 처리와 단순한 조회 작업을 분리하여 성능을 높일 수 있습니다.

앞에서 들었던 배달 서비스에서 고객이 주문 상태를 조회하는 작업(읽기)과 새로운 주문을 생성하는 작업(쓰기)을 분리하여 처리합니다. 예를 들어, 고객이 주문 상태를 확인할 때는 캐시된 데이터를 사용하여 빠르게 응답하고, 새로운 주문은 별도의 서비스에서 트랜잭션을 통해 처리합니다. 이를 통해 시스템 성능을 최적화하고, 읽기와 쓰기 간의 복잡성을 줄일 수 있겠습니다.


하지만 도입 시 예상되는 문제점 또한 존재합니다.
CQRS를 도입하면 읽기와 쓰기 모델이 분리되기 때문에, 지연 복제와 같은 데이터 동기화의 복잡성이 증가할 수 있습니다. 특히, 데이터가 변경된 후 조회 데이터에 이를 반영하는 타이밍 문제를 해결해야 합니다.

 이러한 이벤트 소싱과 CQRS는 특히 분산 시스템에서 데이터의 일관성과 확장성을 동시에 달성하기 위한 중요한 도구입니다. 하지만 두 가지 모두 설계와 구현이 복잡하며, 시스템에 적절하게 도입하기 위해서 고려할 사항들이 많은데요.
이벤트 소싱에서는 모든 이벤트가 순서대로 처리되어야 하므로, 이벤트 처리 순서를 보장하는 것이 핵심입니다. 또한, CQRS에서는 읽기와 쓰기 사이의 데이터 동기화 지연을 어떻게 관리할 것인지가 중요한 요소가 될 수 있겠네요.

그리고 그 해결책 중 하나인 Kafka에 대해서 알아보도록 하겠습니다!



## 3. Kafka를 활용한 분산 환경에서의 일관성 관리



### 3.1 Kafka란?



우선 Kafka가 무엇인지 대해 살짝 소개해드리겠습니다.
**Apache Kafka**는 고성능 분산 메시지 스트리밍 플랫폼입니다. Kafka는 데이터를 효율적으로 전송하고 처리하기 위한 **프로듀서(Producer)**, **컨슈머(Consumer)**, **토픽(Topic)** 등의 구성 요소로 이루어져 있습니다. 특히 대량의 데이터를 빠르게 처리하고, 시스템 간 메시지를 안정적으로 전달하는 데 강점을 가지고 있습니다.



Kafka의 주요 특징 중 하나는 **파티션**을 통해 데이터를 분산시키고, **복제**를 통해 데이터 일관성을 유지하는 메커니즘이 있는데요. 여러 분산 서버 환경을 가진 인터넷 쇼핑몰에서는 주문 정보를 여러 지역별 서버에 동시에 전달하여 빠르게 주문 상태를 업데이트하는 것을 예시로 들 수 있겠습니다.


분산 환경에서 데이터 일관성과 가용성을 동시에 확보하는 것은 매우 어려운 과제입니다. 앞서 설명한 **CAP 이론**에 따르면, 분산 시스템에서 **일관성**과 **가용성**, **파티션 허용성** 중 세 가지를 동시에 만족시키는 것은 불가능합니다. 이러한 한계 속에서 **Kafka**는 분산 환경에서 데이터 일관성을 보장하는 데 매우 유용한 도구로 자리 잡고 있습니다.


### 3.2 Kafka를 통한 데이터 일관성 보장



Kafka는 다양한 일관성 보장 모드를 제공한다고 합니다. Kafka는 설정에 따라 최종 일관성 또는 보다 강한 일관성(at-least-once, exactly-once 등)을 보장할 수 있습니다. Kafka는 메시지를 **복제**하여 데이터 손실 없이 일관성을 유지하는데, 각 파티션의 **리더**가 데이터를 관리하고, **팔로워**들이 이를 복제합니다. 이를 통해 데이터 일관성이 손상되지 않도록 보장할 수 있습니다.



커머스 서비스를 통해 생각해볼까요? 고객이 결제를 완료한 시점에서 이 결제 정보가 Kafka 토픽에 기록되고, 여러 서버에서 이를 실시간으로 구독하여 일관된 결제 상태를 유지할 수 있습니다. 이를 통해 구매 완료 이후 고객이 보는 결제 상태가 불일치하지 않도록 합니다.



### 3.3 Kafka Streams와 실시간 처리

 Kafka Streams는 실시간 데이터 스트리밍을 처리하고, 상태 저장소(state store)와 동기화하여 일관성을 유지할 수 있는 도구입니다.
 배달 서비스에서 라이더의 위치 정보를 Kafka Streams를 통해 처리하여 고객이 보는 라이더의 위치가 실시간으로 일관되게 업데이트될 수 있는 것도 이 도구를 사용한다면 가능한 일이겠네요!



따라서, Kafka를 사용하는 이유는 다음과 같이 요약할 수 있습니다


1. **일관성과 가용성의 균형 유지**:
Kafka는 기본적으로 **최종 일관성(Eventual Consistency)** 을 제공하는 시스템으로 설계되었습니다. 즉, 분산된 여러 노드 간 데이터가 즉시 일치하지 않더라도, 시간이 지나면 결국 동일한 데이터를 확인할 수 있는 **BASE 모델**을 따릅니다. 이를 통해 가용성을 우선시하면서도, 일관성을 어느 정도 유지할 수 있는 분산 시스템을 구축할 수 있습니다. 특정 사용자의 주문 상태가 여러 지역 서버 간에 일시적으로 다를 수 있지만, 최종적으로는 동일한 상태로 유지될 수 있는 것과 같은 효과이지요.

2. **데이터 복제와 내결함성**:
Kafka는 **데이터 복제(replication)** 기능을 제공하여, 각 파티션의 데이터를 여러 노드에 복제하고, 리더-팔로워 구조를 통해 일관성을 유지합니다. 이는 데이터가 손실되거나 특정 노드에서 장애가 발생해도, 다른 복제본을 통해 데이터가 안전하게 유지될 수 있게 하는데요. 이를 통해 **파티션 허용성**을 유지하면서도 시스템을 복구 가능한 상태로 유지하도록 합니다. 쉽게 말하자면, 데이터가 한 서버에서 손실되더라도 다른 서버에서 데이터를 복구할 수 있다는 것입니다.

3. **실시간 데이터 처리 및 스트리밍**:
앞서 설명하였듯이, Kafka는 **실시간 데이터 처리**에 적합한 도구입니다. 대용량 데이터를 빠르고 안정적으로 전송할 수 있는 분산 메시징 시스템이며, 특히 **Kafka Streams**를 사용하면 실시간으로 데이터를 처리하면서도 시스템이 일관된 데이터를 제공하도록 할 수 있습니다. 이 점은 이벤트 기반 아키텍처나, 대규모 트래픽을 처리하는 분산 시스템에서 매우 유리합니다.

4. **확장성과 성능**:
Kafka는 **확장성**이 뛰어나며, 수많은 노드에서 동시에 데이터를 읽고 쓸 수 있도록 설계되었습니다. 이는 대규모 분산 시스템에서 중요한 요소로 노드가 추가되거나 트래픽이 급증해도 성능 저하 없이 시스템이 계속해서 운영될 수 있게 해주며, Kafka의 **파티션** 기능은 데이터를 여러 분할된 단위로 처리하여 성능을 최적화해 준다고 합니다.

5. **유연한 일관성 모델**:
Kafka는 다양한 일관성 모드를 지원합니다. 기본적으로는 최종 일관성을 제공하지만, 필요에 따라 **강한 일관성**(strong consistency)을 요구하는 트랜잭션 처리 방식을 제공하는데요, 시스템의 요구 사항에 따라 유연하게 일관성 수준을 선택할 수 있는 장점이 있겠습니다.



이러한 이유로 Kafka는 분산 환경에서 데이터 일관성을 유지하고, 시스템의 성능과 확장성을 극대화하기 위한 핵심 도구로 널리 사용됩니다. Kafka는 CAP 이론에서 완벽한 일관성과 가용성을 모두 제공할 수 없다는 한계를 인정하면서도, 시스템의 비즈니스 요구사항에 맞추어 일관성과 가용성 간의 균형을 유연하게 조정할 수 있게 해주는 유용한 도구입니다.



## 4. 커머스와 배달 서비스에서의 Kafka 사용 예시

Kafka가 배달 서비스에서 어떻게 유용하게 사용될 수 있는지, 실제 상황을 가정한 예시를 통해 살펴보겠습니다.


### 4.1 배달 서비스에서의 Kafka 사용 예시
**아래 사용되는 예시는 실제 배달 앱과는 전혀 관련이 없는 가상의 예시입니다.**


#### 4.2.1 복잡한 주문 처리 및 라이더 배정 케이스
배달 서비스는 단순히 주문을 받고 라이더를 배정하는 과정으로 끝나지 않습니다. 여러 단계와 예외 상황을 처리해야 하며, Kafka를 사용하는 것과 사용하지 않는 경우의 차이점을 더욱 복잡한 시나리오에서 구체적으로 살펴보겠습니다.

**Kafka 없이 진행되는 경우**


1. 주문 요청 및 처리
   - 고객이 배달 앱을 통해 음식을 주문합니다.
   - 서버가 주문 정보를 데이터베이스에 기록하고, 인근의 라이더를 찾습니다.

2. 라이더 배정과 알림
   - 서버는 인근에 있는 라이더를 찾아 배정하고, 라이더 앱에 알림을 보냅니다.
   - 여러 주문 동시 처리: 특정 시간대(예: 점심시간)에는 동시에 수백 건의 주문이 발생할 수 있습니다. 이때 모든 주문에 대해 인근 라이더를 찾고, 배정하는 과정에서 서버 부하가 커질 수 있습니다.

3. 문제 발생 가능성

- 라이더 알림 누락: 네트워크 문제나 서버 과부하로 인해 일부 라이더가 알림을 받지 못해 배달이 지연될 수 있습니다.
- 주문 데이터 손실: 주문이 데이터베이스에 완전히 기록되기 전에 서버에 장애가 발생하면 주문이 손실되어 고객이 결제가 이루어졌음에도 불구하고 음식이 준비되지 않을 수 있습니다.
- 실시간 상태 업데이트 누락: 고객이 주문 상태를 실시간으로 확인하려고 할 때, 주문이 여러 서버로 분산 처리되면 정확한 상태를 표시하지 못하는 경우가 발생할 수 있습니다.


**Kafka를 사용하는 경우**


1. 주문 요청 이벤트 생성
   - 고객이 음식을 주문하면 프로듀서(Producer) 가 이 주문 요청을 이벤트로 Kafka에 기록합니다.
   - Kafka는 주문 요청 이벤트를 특정 **토픽(Topic)** 에 기록하고, 이벤트는 시스템의 모든 관련 서버에서 접근할 수 있도록 관리됩니다.

2. 주문 처리 및 라이더 배정 이벤트
   - 컨슈머(Consumer) 가 주문 요청 이벤트를 구독하고 주문 정보를 데이터베이스에 기록한 후, 인근의 라이더를 찾습니다.
   - 이때 라이더 배정 정보 역시 Kafka 토픽에 기록됩니다. 여러 컨슈머가 동시에 구독하여 효율적으로 라이더를 배정할 수 있어, 동시에 수백 건의 주문이 처리되어도 부하를 분산할 수 있습니다.

3. 복잡한 예외 상황 처리

   - 라이더 부재 상황: 만약 특정 지역에 라이더가 부족한 상황이 발생하면, Kafka에 기록된 이벤트가 이를 다른 지역의 백업 라이더들에게 자동으로 전달되도록 설정할 수 있습니다.
   - 주문 취소 처리: 고객이 주문을 취소했을 때, Kafka에 주문 취소 이벤트를 기록합니다. 이를 통해 모든 관련 서버가 주문 취소를 즉시 반영하고, 이미 배정된 라이더에게도 취소 알림이 전달됩니다.

4. 장애 복구 및 데이터 일관성 유지

   - Kafka는 주문, 라이더 배정, 주문 취소 등 모든 이벤트를 안전하게 복제하여 저장하므로, 만약 시스템 장애가 발생해도 모든 이벤트를 다시 재생하여 이전 상태로 복구할 수 있습니다.
   - 멱등성 보장: Kafka는 이벤트 재처리 시 멱등성을 보장하므로, 중복된 주문 배정이나 주문 처리와 같은 문제를 방지할 수 있습니다.

5. 실시간 상태 업데이트 및 알림

   - Kafka Streams를 통해 모든 주문과 라이더 상태 변경이 실시간으로 고객과 라이더 앱에 업데이트됩니다. 고객은 자신의 주문이 언제 준비되었고, 라이더가 언제 도착할지에 대해 실시간으로 확인할 수 있습니다.
   - 여러 디바이스 동기화: Kafka를 사용하면 주문 상태가 여러 디바이스(예: 고객의 스마트폰, 매장의 태블릿, 라이더의 스마트폰)에 동시에 업데이트됩니다. 이를 통해 모든 관련 참여자들이 동일한 정보를 실시간으로 확인할 수 있습니다.


#### 4.2.2 다중 음식점 및 여러 라이더와의 상호작용

 오 우리 고객님께서 홈파티를 여셨나 봅니다! 배달 앱을 통해 여러 음식점에서 동시에 파티 음식을 주문하는 경우를 가정해 보겠습니다.

**Kafka 없이 진행되는 경우**

1. 주문 요청 및 처리

   - 고객이 여러 음식점에서 주문을 동시에 요청합니다.
   - 각 음식점은 자체적으로 주문을 수신하고, 각기 다른 서버에서 주문을 처리하게 됩니다.
   - 서버는 각각의 음식점에서 주문이 완료된 후, 각기 다른 라이더를 배정해야 합니다.

2. 문제 발생 가능성

   - 주문 연계 처리 어려움: 각 음식점에서 주문을 별도로 처리하다 보면, 피자와 디저트가 각각 다른 시간에 배달되어 고객이 모든 음식을 동시에 받기 어렵습니다.
   - 라이더 배정 혼란: 각각 다른 음식점의 주문에 대해 각각 라이더가 배정되면서, 고객은 두 명 이상의 라이더로부터 음식을 받아야 하는 번거로움을 겪을 수 있습니다.


**Kafka를 사용하는 경우**

1. 통합 주문 처리 이벤트

   -고객이 여러 음식점에서 동시에 주문하면 Kafka는 통합 주문 이벤트를 생성하여 Kafka 토픽에 기록합니다.
   - 이를 통해 각각의 음식점의 주문이 하나의 이벤트로 연결되며, 컨슈머(Consumer) 들이 이를 구독하여 모든 음식점의 주문 상태를 중앙에서 통합적으로 관리할 수 있습니다.

2. 주문 준비 상태 통합 관리

   - Kafka Streams는 각 음식점에서 준비되는 음식의 상태를 실시간으로 통합하여 고객에게 업데이트합니다.
   예를 들어, 피자가 준비되는 동안 디저트의 준비 상태도 같이 확인할 수 있어 고객은 전체 주문이 언제 완료될지 한눈에 볼 수 있습니다.

3. 효율적인 라이더 배정

   - Kafka는 모든 주문이 준비되는 시점에 맞추어 한 명의 라이더가 모든 음식을 픽업하도록 라이더 배정 이벤트를 조율할 수 있습니다.
   - 이를 통해 고객은 여러 음식점에서 주문한 모든 음식을 한 번에 받을 수 있습니다.

4. 문제 발생 시 복구 및 재처리

   - 예를 들어, 음식점 중 하나에서 갑작스럽게 재료가 부족해 준비가 지연되는 경우 Kafka는 해당 이벤트를 기록하고, 고객에게 즉시 상태 업데이트와 선택 옵션(예: 대체 음식 선택 또는 주문 취소)을 제공합니다.
   - Kafka의 멱등성 보장 덕분에 라이더가 이미 음식점 중 한 곳에 도착했더라도, 추가 배달 지시를 통해 음식 픽업 및 배달의 일관성을 유지할 수 있습니다.
   

#### 4.2.3 대규모 이벤트 및 피크 트래픽 상황에서의 Kafka 사용 예시

앗! 월드컵이 개최됐네요 축구 경기와 함께하는 치킨은 못참죠. 이때 배달 주문이 폭증하는 경우를 가정해 보겠습니다.

**Kafka 없이 진행되는 경우**

특정 이벤트 기간 동안 주문이 폭증하면 서버는 수백만 건의 주문 요청을 동시에 처리해야 합니다. 서버가 과부하로 인해 다운되거나 주문 처리 속도가 느려질 수 있습니다.
네트워크 병목 현상이 발생하여 주문 데이터가 유실되거나 고객이 결제 완료 이후에도 주문이 서버에 반영되지 않는 문제가 발생할 수 있습니다.

**Kafka를 사용하는 경우**

1. 주문 요청 버퍼링

   - Kafka는 주문 요청 이벤트를 버퍼링할 수 있으므로, 갑작스럽게 주문이 폭증해도 주문 이벤트가 Kafka 토픽에 안전하게 기록됩니다. 이를 통해 서버는 실시간으로 모든 주문을 처리하지 않아도 되고, 일정한 속도로 주문을 컨슈머에게 전달하여 처리하게 됩니다.

2. 서버 과부하 방지

   - 각 주문 이벤트는 Kafka의 여러 파티션으로 분산되어 저장되므로, 서버 과부하를 효과적으로 방지할 수 있습니다.
   - 예를 들어, 수십만 건의 주문이 동시에 들어올 때에도 Kafka가 이를 여러 파티션으로 나누어 다수의 서버에 분산 처리하게 함으로써 서버가 다운되지 않고 안정적으로 운영됩니다.

3. 실시간 알림 및 고객 피드백

   - Kafka Streams는 주문 처리 상황을 실시간으로 분석하여, 고객이 주문 상태와 예상 배달 시간을 즉시 확인할 수 있도록 도와줍니다.
   - 할인 이벤트의 효과를 실시간으로 분석하고, 특정 지역에서 주문이 폭증하는 경우 해당 지역의 라이더 배치를 자동으로 조정하는 데 도움을 줄 수 있습니다.
   - 이와 같이 Kafka를 배달 서비스에 도입함으로써 발생할 수 있는 다양한 복잡한 상황과 문제들을 효과적으로 해결하고, 시스템의 안정성과 성능을 보장할 수 있습니다. Kafka는 데이터를 안전하고 효율적으로 관리하여, 고객, 음식점, 라이더 모두에게 일관된 경험을 제공하는 중요한 역할을 합니다.

정리해 보자면 다음과 같습니다.

#### **Kafka 사용 전후 비교**

| **Kafka를 사용하지 않은 경우**   | **Kafka를 사용한 경우**          |
| ----------------------- | -------------------------- |
| 트랜잭션 중단 시 데이터 불일치 발생 가능 | 이벤트 소싱으로 트랜잭션 재처리 가능       |
| 네트워크 장애 시 복구 어려움        | Kafka에 기록된 이벤트로 복구 용이      |
| 데이터베이스 간 동기화 문제 발생 가능   | 이벤트 기반으로 데이터 일관성 유지        |
| 트랜잭션 실패 시 수동 롤백 필요      | 장애 복구 후 이벤트 재처리로 자동 해결     |
| 실시간 데이터 업데이트 어려움        | Kafka Streams로 실시간 업데이트 가능 |
| 데이터 손실 가능성              | Kafka의 복제 기능으로 데이터 안전 보장   |

---


## 끝으로
분산 환경에서 데이터 일관성과 멱등성을 유지하기 위한 여러 가지 방법을 소개했습니다. Kafka는 그중 하나의 도구로, 실시간 데이터 처리와 복제 기능을 통해 일관성을 유지하는 데 효과적일 수 있습니다. 하지만 모든 시스템이 Kafka에 적합한 것은 아닙니다. 시스템의 특성, 요구사항, 트래픽 패턴, 그리고 서비스의 우선순위에 따라 **CAP 이론**을 기반으로 적절한 전략을 선택해야 합니다. 때로는 **ACID** 트랜잭션이 필요한 강한 일관성이 요구되기도 하고, 반대로 **BASE** 모델처럼 유연성을 더 중시하는 접근이 필요할 수도 있습니다. 결국 중요한 것은 각각의 방법론과 도구들이 지닌 장단점을 이해하고, 상황에 맞는 적절한 해결책을 선택하는 것이라고 합니다.




**참고 자료**
1. [Apache Kafka 공식 문서](https://kafka.apache.org/documentation/)

2. [CAP Theorem 이해](https://en.wikipedia.org/wiki/CAP_theorem)

3. [Designing Data-Intensive Applications (Martin Kleppmann)](https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/)

4. [우아한형제들 | 우아콘2023 - 대규모 트랜잭션을 처리하는 배민 주문시스템 규모에 따른 진화](https://www.youtube.com/watch?v=704qQs6KoUk&t=1317s)

5. [우아한형제들 | 우아콘2023 - Kafka를 활용한 이벤트 기반 아키텍처 구축](https://www.youtube.com/watch?v=DY3sUeGu74M)

6. [토스ㅣSLASH 22 - 왜 은행은 무한스크롤이 안되나요](https://youtu.be/v9rcKpUZw4o?si=gCIKSDciO_Clnnr9)


> 글쓴이(김도엽 | 도비)의 Github:
> 
> https://github.com/Dobby-Kim
