---
author: "parkhanyoung"
generation: 6
level: "unclassified"
original_filename: "TECH.md"
source: "https://github.com/woowacourse/woowa-writing/blob/parkhanyoung/TECH.md"
source_path: "TECH.md"
---

# 에러 바운더리가 비동기 에러를 잡지 못하는 이유

## 목차

1. 서론

- 1.1 대상 독자
- 1.2 주제 선정 배경

2. 이론 배경

- 2.1 실행 컨텍스트와 콜스택
- 2.2 비동기 작업 처리 방식
- 2.3 동기 에러 전파 흐름
- 2.4 에러 바운더리(Error Boundary)의 에러 감지 방식

3. 에러 바운더리가 비동기 에러를 잡지 못하는 이유

4. 에러 바운더리가 비동기 에러를 잡게 하는 방법

5. 요약

6. 결론

## 1. 서론

### 1.1 예상 독자

이 글을 이해하기 위해서는 자바스크립트의 **이벤트 루프**, **리액트**, 그리고 **에러 핸들링**에 대한 기본적인 이해도가 있어야 합니다. 자바스크립트의 이벤트 루프와 에러 바운더리의 동작을 이해하고자 하는 분들을 대상으로 합니다. 특히, 에러 바운더리를 실제로 사용하는 과정에서 어려움을 직접 겪어보신 분이라면 도움이 될 것이라 생각합니다.

### 1.2 주제 선정 배경

현대 웹 개발에서 리액트는 대중적인 프론트엔드 라이브러리로 자리 잡았습니다. 리액트가 각광받는 이유 중 하나는 **선언적**인 형태로 코드를 작성할 수 있다는 점에 있습니다. 이전에는 UI를 그리는 과정을 절차지향적으로 일일이 나열해야 했다면, 리액트를 사용하면서부터는 한눈에 알아보기 좋은 선언적인 코드를 쉽게 작성할 수 있게 되었습니다.

웹 애플리케이션을 구현하는 과정에서 가장 중요한 한 가지는 **에러 처리**입니다. 도메인과 상관없이 안정적인 사용자 경험을 제공하기 위해서는 에러 처리를 잘 해주는 것이 중요합니다. 그런데, 에러 처리를 꼼꼼히 해주는 과정에서 코드의 복잡도가 크게 증가하는 경우가 많습니다. UI 및 도메인 로직과 에러 처리 로직이 혼재하면서 책임의 경계가 모호해지는 경우가 발생하기 때문입니다. 그런데 **리액트 16 버전부터는 에러 처리를 선언적으로 처리**할 수 있도록 하는 기능이 추가되었습니다. 그 기능이 바로 **에러 바운더리**입니다. 클래스형 컴포넌트의 [`static getDerivedStateFromError()`](https://ko.legacy.reactjs.org/docs/react-component.html#static-getderivedstatefromerror) 와 [`componentDidCatch()`](https://ko.legacy.reactjs.org/docs/react-component.html#componentdidcatch) 메서드를 이용하여 에러 바운더리를 구현할 수 있게 되었습니다. 에러 바운더리를 적용하게 되면 UI 및 도메인 로직과 에러 처리 로직의 관심사를 명확히 분리할 수 있습니다. 더불어 에러 처리 방식이 명시적이고 일관되기 때문에 예외에 대한 처리 방법이 코드에 잘 드러납니다.

하지만, 에러 바운더리를 사용하는 과정에서 에러가 예상대로 잡히지 않아 당황하게 되는 경우가 빈번하게 발생하곤 합니다. 이런 경우는 대체로 **비동기적으로 발생한 에러**를 잡으려고 하는 경우입니다. 그런데 프로젝트의 마감기한을 지키기 위해 코드를 서둘러 작성하는 동안에는 동작 방식을 깊이 고민할 시간이 없어 주먹구구식으로 대처하고 넘어가는 경우가 많습니다. 사실, 찬찬히 고민해본다면 자바스크립트의 비동기 함수 실행 방식을 고려했을 때 에러 바운더리에 비동기 에러가 잡히지 않는 것을 어렵지 않게 이해하실 수 있을 겁니다. 이 글을 통해 자바스크립트의 동작 방식을 간단히 살펴보고, 에러 바운더리가 비동기 에러를 잡지 못했던 이유에 대해 명확히 이해해 봅시다.

## 2. 이론 배경

### 2.1 실행 컨텍스트와 콜 스택

먼저 **실행 컨텍스트**와 **콜 스택**에 대한 이해를 바탕으로 자바스크립트에서 함수가 어떤 흐름으로 실행되는지 이해해야 합니다. 먼저 실행 컨텍스트와 콜 스택의 개념에 대해서 간략히 살펴 봅시다.

**실행 컨텍스트**는 간단히 말하면 실행할 코드에 제공할 환경 정보들을 모아놓은 객체입니다.

코드를 실행하는 과정에서 변수, 함수, 클래스 이름 등 여러 식별자의 정보를 참조해야 하는데요. 이를 위해 실행 컨텍스트를 만들어 두고 필요한 정보들을 저장하고 꺼내어 쓴다고 생각하시면 좋을 것 같습니다. 사실, 실행 컨텍스트는 내부에 여러 가지 구성 요소를 포함하고 있어 상당히 복잡하지만, 현재의 맥락에서는 코드를 실행하기 위한 정보를 모아 놓은 곳 정도로만 이해해도 충분합니다.

**콜 스택**은 함수의 앞서 말한 실행 컨텍스트가 쌓이는 스택 형태의 자료구조입니다. 함수가 호출될 때마다 실행 컨텍스트가 콜 스택에 추가되고, 함수 실행이 완료되면 스택에서 제거됩니다. 이러한 과정을 통해 자바스크립트 엔진이 함수 실행 흐름을 제어합니다.

코드 실행 흐름 단계를 설명하면 다음과 같습니다.

1. **함수 호출:** 함수가 호출되면 해당 함수의 실행 컨텍스트가 생성되고 콜 스택에 추가(push)됩니다.
2. **코드 실행:** 콜 스택의 맨 위에 있는 실행 컨텍스트의 코드가 실행됩니다. 만약 실행된 함수 내에 또 다른 함수 호출이 존재한다면 1, 2의 과정을 반복합니다.
3. **함수 종료:** 함수 실행이 완료되면 해당 실행 컨텍스트는 콜 스택에서 제거(pop)됩니다.
4. **상위 함수로 복귀:** 콜 스택 상 아래에 위치한, 상위 함수의 실행으로 돌아갑니다.

역시 글로만 살펴 보니 이해가 잘 되지 않는데요. 실제 코드 예시와 그림을 살펴보며 더 구체적으로 이해해 봅시다.

**예시 코드**

```js
function first() {
  second();
}

function second() {
  third();
}

function third() {
  console.log("Hello World");
}

first();
```

이 예시 코드의 실행 흐름을 콜 스택 관점에서 살펴보면 다음과 같습니다.

<img width="600px" src="https://raw.githubusercontent.com/woowacourse/woowa-writing/parkhanyoung/image/callstack-process.png">
  
1. **```first()``` 호출**: ```first()```가 호출되어 ```first()```의 실행 컨텍스트가 콜 스택에 추가됩니다.
2. **```second()``` 호출:** ```first()``` 내부에서 ```second()```가 호출되어 ```second()```의 실행 컨텍스트가 콜 스택 내 ```first()``` 실행 컨텍스트 위로 쌓입니다.
3. **```third()``` 호출:** ```second()``` 내부에서 ```third()```가 호출되어 ```third()```의 실행 컨텍스트가 ```second()```의 실행 컨텍스트 위로 쌓입니다.
4. **```third()``` 종료:** ```third()``` 내부 ```console.log()```가 실행된 후, ```third()```의 실행 컨텍스트가 콜 스택에서 제거됩니다.
5. **```second()``` 종료:** 상위 함수인 ```second()```로 실행 흐름이 이동합니다. ```second()```의 실행이 종료되었으므로 ```second()```의 실행 컨텍스트가 콜 스택에서 제거됩니다.
6. **```first()``` 종료:** 상위 함수인 ```first()```로 실행 흐름이 이동합니다. ```first()```의 실행이 종료되었으므로 ```first()```의 실행 컨텍스트가 콜 스택에서 제거됩니다.

### 2.2 비동기 작업 처리 방식

자바스크립트는 **싱글 스레드 언어**입니다. 즉, 자바스크립트를 실행하는 엔진은 **하나의 메인 스레드**를 가지고 한 번에 하나의 작업만을 처리할 수 있습니다. 하지만 실질적으로 따져보면 정말 한 번에 하나의 작업만 수행할 수 있는 건 아닙니다. 예를 들면, `fetch()`를 통해 웹 요청을 보낼 때 응답이 올 때까지 다른 일을 수행할 수 있습니다. 웹 요청을 보내는 동안 `setTimeout()`을 통해 타이머를 설정해둘 수도 있습니다. 싱글 스레드인 엔진이 이 모든 것을 어떻게 한 번에 처리하는 것일까요?

<img width="600px" src="https://raw.githubusercontent.com/woowacourse/woowa-writing/parkhanyoung/image/eventloop.png">
  
사실 자바스크립트 엔진의 메인 스레드는 **브라우저의 런타임 환경(Web API, 이벤트 루프)과 협력**하여 작업을 처리합니다. 메인 스레드가 ```fetch()```나 ```setTimeout()```과 같은 비동기 함수를 실행하면, 해당 작업은 브라우저의 Web API에 의해 백그라운드 스레드에서 처리됩니다. Web API가 작업을 모두 처리하고 나면 등록된 콜백 함수가 콜백 큐에 추가됩니다. 그 후 콜 스택이 비게 되면, 약속된 순서에 따라 콜백 큐에 있는 콜백 함수들이 이벤트 루프에 의해 콜 스택으로 이동됩니다. 여기서 기억해야 하는 부분은 **콜백 큐의 함수들은 콜 스택이 비어 있을 때야 비로소 실행된다는 점**입니다.

### 2.3 에러 전파 흐름

에러가 발생하면 현재 실행 컨텍스트가 콜 스택에서 제거되며 에러는 **상위 호출자로 전파**됩니다. 더 구체적으로 이야기하면, 에러가 발생한 실행 컨텍스트에서 출발하여 **상위 실행 컨텍스트로 전파**됩니다. 상위 실행 컨텍스트에서도 에러가 잡히지 않으면 계속해서 상위로 전파됩니다. 그러다가 최상위 실행 컨텍스트인 글로벌 실행 컨텍스트에서도 에러가 잡히지 않으면 크래시가 발생합니다. 즉, 해당 에러는 `Uncaught Error`로 간주되며 스크립트 실행이 중단됩니다.

실제 코드 예시를 살펴봅시다.

```js
function first() {
  console.log("App is starting...");

  second();
}

function second() {
  third();
}

function third() {
  throw new Error("Something went terribly wrong!");
}

first();

console.log("This line will never be executed");
```

위 스크립트의 실행 결과는 아래와 같습니다.

```
App is starting...
Uncaught Error: Something went terribly wrong!
```

`first()`에서 발생한 에러가 상위 컨텍스트인 `second()`, `third()`로 전파되었고, 최상위에서도 에러가 잡히지 않아 앱이 중단되었습니다.

<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/parkhanyoung/image/error-flow.png">

1. `third()`에서 에러가 발생합니다.
2. `third()`에서 발생한 에러가 `second()`로 **전파**됩니다.
3. `third()`에서 발생한 에러가 `first()`로 **전파**됩니다.
4. 에러가 최상위 컨텍스트에서도 잡히지 않아 **앱이 중단됩니다**.

### 에러 바운더리의 에러 감지 방식

컴포넌트에서 발생하는 에러도 당연히 **일반적인 에러의 전파 흐름과 동일**합니다. 자식 컴포넌트에서 발생한 에러는 부모 컴포넌트로 전파됩니다. 그리고 부모 컴포넌트에서도 처리되지 않는다면, 부모의 부모 컴포넌트로 전파되고 최상위 컴포넌트에서도 처리되지 않는다면 크래시가 발생합니다.

에러 바운더리는 하위 컴포넌트에서 전파된 에러를 잡아냅니다. try catch 문을 이용하여 하위 실행 컨텍스트에서 발생한 에러를 잡아내는 것과 유사합니다.

<img width="600px" src="https://raw.githubusercontent.com/woowacourse/woowa-writing/parkhanyoung/image/error-boundary-catch-flow.png">

1. `Child()`에서 에러가 발생합니다.
2. `Child()`에서 발생한 에러를 ErrorBoundary가 잡아냅니다.

## 3. 에러 바운더리가 비동기 에러를 잡지 못하는 이유

앞선 내용에 대한 이해를 바탕으로 에러 바운더리가 비동기 에러를 잡지 못하는 이유를 실제 코드와 함께 살펴 보겠습니다. 요약하면, 에러 바운더리가 비동기 에러를 잡지 못하는 이유는 자바스크립트의 **비동기 처리 메커니즘**과 **콜 스택 및 이벤트 루프의 동작 방식**에 기인합니다.

```js
function Child() {
  const funcWithError = () => {
    throw new Error("error occurs!");
  };

  setTimeout(funcWithError, 100);

  return <div>I am child</div>;
}

function Parent() {
  return (
    <ErrorBoundary>
      <Child />
    </ErrorBoundary>
  );
}
```

Child라는 자식 컴포넌트에서 비동기적으로 에러를 발생시키고 있습니다. Parent는 자식 컴포넌트인 Child를 ErrorBoundary로 감싸고 있습니다. 위 코드에서 Child 컴포넌트 내부의 funcWithError는 setTimeout을 통해 비동기적으로 호출됩니다. Parent 컴포넌트는 Child를 ErrorBoundary로 감싸고 있지만, 비동기적으로 발생하는 에러는 ErrorBoundary가 감지하지 못합니다.

이를 실행 흐름에 따라 설명하면 다음과 같습니다.

<img src="https://raw.githubusercontent.com/woowacourse/woowa-writing/parkhanyoung/image/async-error-flow.png">

1. setTimeout()이 실행되어 콜백으로 등록된 `funcWithError()`는 100ms 후 태스크 큐에 등록됩니다.
2. Child 컴포넌트의 실행 컨텍스트가 콜 스택에서 제거됩니다.
3. ErrorBoundary의 실행 컨텍스트가 콜 스택에서 제거됩니다.
4. Parent 컴포넌트의 실행 컨텍스트가 콜 스택에서 제거됩니다.
5. 콜 스택이 비어있게 됐으므로 `funcWithError`가 실행됩니다. 이 시점에 ErrorBoundary의 실행 컨텍스트는 이미 콜 스택에서 사라진 상태입니다.

결과적으로 Child를 감싸고 있는 ErrorBoundary는 Child에서 **비동기적으로 발생하는 에러를 잡아내지 못합니다**. 그 이유는 콜백 큐에 등록된 `funcWithError()`이 실행되는 시점에 ErrorBoundary의 실행 컨텍스트가 이미 제거된 이후이기 때문입니다.

## 4. 에러 바운더리가 비동기 에러를 잡게 하는 방법

비동기 에러를 잡을 수 있도록 만들려면 어떻게 해야 할까요?

사실 아쉽게도 에러 바운더리가 비동기 에러를 직접적으로 감지할 수 있게 하는 방법은 없습니다. 자바스크립트 엔진이 동작하는 방식을 고칠 수는 없기 때문입니다. 하지만 비동기 에러를 동기적인 에러로 다시 던져주어서 간접적으로나마 에러 바운더리가 비동기적으로 발생한 에러를 잡게 만들 수 있습니다. 그리고 이 방법은 생각보다 간단하게 구현이 가능합니다.

```js
function Child() {
  const [error, setError] = useState(null);

  const funcWithError = () => {
    try {
      throw new Error("something terrible happens!");
    } catch (error) {
      setError(error); // 에러 발생 시 상태를 업데이트
    }
  };

  // 비동기 에러가 발생
  setTimeout(funcWithError, 100);

  // 에러 상태가 존재할 경우 동기적으로 에러 던지기
  if (error) {
    throw new Error("error occurs!!"); // 동기적 에러로 에러 바운더리가 감지 가능
  }

  return <div>I am child</div>;
}
```

위 코드에서 funcWithError 함수는 비동기적으로 실행되며, 이 안에서 에러가 발생할 경우 catch 문에서 setError를 통해 에러를 state에 저장합니다.

이후 렌더링 과정에서 error 상태를 감지하여 에러가 존재할 경우 throw를 통해 동기적 에러로 변환해 줍니다. 이로 인해 에러 바운더리는 렌더링 과정에서 던져진 에러를 감지하게 됩니다.

**코드 흐름**

1. `setTimeout`을 이용해 `funcWithError` 함수가 비동기로 실행되도록 설정합니다.
2. `funcWithError` 내부에서 에러가 발생하면 try-catch 블록이 에러를 감지하여 `setError`로 상태를 업데이트합니다.
3. 이후 렌더링 과정에서 error 상태가 `null`이 아니라는 것을 확인하면, 동기적 throw를 이용해 에러를 다시 발생시킵니다.
4. 이렇게 던져진 에러는 동기적이므로, 에러 바운더리가 이를 감지하고 에러를 처리할 수 있게 됩니다.

## 5. 요약

ErrorBoundary는 React에서 에러 처리를 선언적으로 관리할 수 있도록 도와주는 강력한 도구입니다. 그러나 자바스크립트의 비동기 처리 메커니즘과 에러 전파 방식으로 인해, 비동기 작업 중 발생한 에러는 에러 바운더리가 감지하지 못하는 한계가 존재했습니다. 이를 해결하기 위해 비동기 에러를 동기적으로 다시 던져주는 방법을 사용하여 ErrorBoundary가 감지할 수 있도록 만들 수 있었습니다. setState를 이용해 에러 상태를 업데이트하고, 이후 렌더링 시 해당 에러를 다시 동기적 예외로 전환해 ErrorBoundary가 감지하도록 하는 방식이었습니다.

## 6. 결론

빠르게 개발을 진행하는 것도 물론 중요합니다. 그러나 안정적이고 확장 가능한 코드를 작성하기 위해서는 때때로 기술의 근본적인 동작 방식과 원리에 대해 깊이 탐구하는 시간이 필요합니다. 프로그래밍에서 동작 원리를 이해하지 못한 채 문제 해결에만 급급하다 보면, 임시방편적인 해결책을 선택하게 되고 이는 결국 기술 부채로 이어질 수 있습니다. 에러 바운더리가 비동기 에러를 잡지 못하는 현상도 마찬가지였습니다. 단순히 "에러 바운더리가 비동기 에러를 못 잡는구나"라고 생각하고 넘어갈 수도 있지만, 그 이면에 있는 자바스크립트의 동작 원리를 이해함으로써 더 나은 해결책을 생각해낼 수 있었습니다. 더불어 자연스레 실행 컨텍스트, 이벤트 루프, 에러 전파 방식 등에 대해서 본질적인 고민을 해보는 시간을 가질 수 있었습니다.

## 참고 문헌

[ErrorBoundary 가 포착할 수 없는 에러와 그 이론적 원리 분석](https://happysisyphe.tistory.com/66)  
[이벤트 루프와 매크로태스크, 마이크로태스크](https://ko.javascript.info/event-loop)  
[wikidocs - Event Loop](https://wikidocs.net/251900)
